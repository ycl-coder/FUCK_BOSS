{
  "id": "approval_1767670156534_7z9dio7kh",
  "title": "技术栈文档 (tech.md) - DDD架构、PostgreSQL、Redis",
  "filePath": ".spec-workflow/steering/tech.md",
  "type": "document",
  "status": "needs-revision",
  "createdAt": "2026-01-06T03:29:16.534Z",
  "category": "steering",
  "categoryName": "steering",
  "response": "Feedback Summary (1 comments):\n\nSpecific Text Comments:\n1. \"# Technology Stack\": 可以将 代码规范 放进去：\n\n Golang 代码规范\n1. 前言\n为形成公司统一的 Go 编码风格，以保障公司项目代码的易维护性和编码安全性，特制定本规范。\n每项规范内容，给出了要求等级，其定义为：\n\n[火箭]\n\n必须（Mandatory）：用户必须采用。\n\n[火]\n\n推荐（Preferable）：用户理应采用，但如有特殊情况，可以不采用。\n\n[灯泡]\n\n可选（Optional）：用户可参考，自行决定是否采用。\n2. 代码风格\n2.1 【必须】格式化\n● 代码都必须用gofmt格式化。\n2.2 【推荐】换行\n● 建议一行代码不要超过 120 列，超过的情况，使用合理的换行方法换行。\n2.3 【必须】括号和空格\n\n[火箭]\n\n遵循gofmt的逻辑。\n\n[火]\n\n运算符和操作数之间要留空格。\n\n[灯泡]\n\n作为输入参数或者数组下标时，运算符和运算数之间不需要空格，紧凑展示。\n2.4 【必须】import规范\n\n[火箭]\n\n使用goimports自动格式化引入的包名。\n\n[火]\n\n引入单个包，也使用括号包裹。\n// 应该采用如下格式：\nimport (\"fmt\")\n// 而不是这样：\nimport \"fmt\"\n\n[火箭]\n\n 如果你引入了多种类型的包，必须对包进行分组管理，将包分为标准库包、程序内部包、第三方包，并将标准库作为第一组，三组包用空行间隔。\n\n[火]\n\ngoimports或者\ngofmt会自动把依赖包按首字母排序。\n\n[灯泡]\n\n匿名包的引用必须使用一个新的分组引入。\n\n[旗子]\n\n不要使用相对路径引入包。\n\n// 不要采用这种方式\nimport (\n  \"../net\"\n)\n● 应该使用完整的路径引入包：\nimport (\n  \"xxxx.com/proj/net\"\n)\n● 包名和git 路径名不一致时，使用别名代替\nimport (\n  opentracing \"github.com/opentracing/opentracing-go\"\n)\n\n[火箭]\n\n【推荐】在匿名引入的每个包上推荐写上注释说明。\n\n[火]\n\n应该采用如下方式进行组织你的包。\nimport (\n  // standard package\n\"encoding/json\"\n\"strings\"\n\n// inner package\n\"myproject/models\"\n\"myproject/controller\"\n\n// third-party package\n\"git.obc.im/obc/utils\"\n\"git.obc.im/dep/beego\"\n\"git.obc.im/dep/mysql\"\n\n// alias package\nopentracing \"github.com/opentracing/opentracing-go\"\n\n// anonymous import package\n// import filesystem storage driver\n_ \"github.com/org/repo/pkg/storage/filesystem\n)\n\n2.5 【必须】错误处理\n2.5.1 【必须】error处理\n\n[火箭]\n\nerror作为函数的值返回，必须对error进行处理, 或将返回值赋值给明确忽略。\n\n[火]\n\nerror作为函数的值返回且有多个返回值的时候，error必须是最后一个参数。\n// 不要采用这种方式\nfunc do() (error, int) {\n}\n// 要采用下面的方式\nfunc do() (int, error) {\n}\n\n[火箭]\n\n错误描述不需要标点结尾。\n\n[火]\n\n采用独立的错误流进行处理。\n// 不要采用这种方式\nif err != nil {\n  // error handling\n} else {\n  // normal code\n}\n\n// 而要采用下面的方式\nif err != nil {\n  // error handling\n  return // or continue, etc.\n}\n// normal code\n\n- 如果返回值需要初始化，则采用下面的方式：\nx, err := f()\nif err != nil {\n  // error handling\n  return // or continue, etc.\n}\n// use x\n\n●  错误返回的判断独立处理，不与其他变量组合逻辑判断。\n// 不要采用这种方式：\nx, y, err := f()\nif err != nil || y == nil {\n  return err   // 当y与err都为空时，函数的调用者会出现错误的调用逻辑\n}\n\n// 应当使用如下方式：\nx, y, err := f()\nif err != nil {\n  return err\n}\nif y == nil {\n  return fmt.Errorf(\"some error\")\n}\n● 【推荐】建议 go1.13 以上，error 生成方式为：fmt.Errorf(\"module xxx: %w\", err)\n\n 2.5.2 【必须】panic 处理\nPANIC\n[火箭] 在业务逻辑处理中禁止使用panic。\n[火] 在main包中只有当完全不可运行的情况可使用panic，例如：文件无法打开，数据库无法连接导致程序无法正常运行。\n[灯泡] 对于其它的包，可导出的接口不能有panic，只能在包内使用。\n[旗子] 建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。\n[火箭]panic捕获只能到goroutine最顶层，每个自行启动的goroutine，必须在入口处捕获panic，并打印详细堆栈信息或进行其它处理。\n2.5.3 【必须】recover处理\n\n[火箭]\n\nrecover 用于捕获runtime的异常，禁止滥用recover。\n\n[火]\n\n必须在defer中使用，一般用来捕获程序运行期间发生异常抛出的panic或程序主动抛出的\npanic。\npackage main\nimport (\n  \"log\"\n)\nfunc main() {\n  defer func() {\n      if err := recover(); err != nil {\n          // do something or record log\n      log.Println(\"exec panic error: \", err)\n          // log.Println(debug.Stack())\n      }\n  }()\n  \n  getOne()\n  \n  panic(11) //手动抛出panic\n}\n// getOne 模拟slice越界 runtime运行时抛出的panic\nfunc getOne() {\n  defer func() {\n      if err := recover(); err != nil {\n          // do something or record log\n      log.Println(\"exec panic error: \", err)\n          // log.Println(debug.Stack())\n      }\n  }()\n  \n  var arr = []string{\"a\", \"b\", \"c\"}\n  log.Println(\"hello,\", arr[4])\n}\n\n// 执行结果：\n// 2020/01/02 17:18:53 exec panic error:  runtime error: index out of range\n// 2020/01/02 17:18:53 exec panic error:  11\n\n2.6 【必须】单元测试\n\n[火箭]\n\n单元测试文件名命名规范为\nexample_test.go。\n\n[火]\n\n测试用例的函数名称必须以\nTest开头，例如\nTestExample。\n\n[灯泡]\n\n每个重要的可导出函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试。\n2.7 【必须】类型断言失败处理\n● type assertion的单个返回值形式针对不正确的类型将产生panic。因此，请始终使用“comma ok”的惯用法。\n// 不要采用这种方式\nt := i.(string)\n// 而要采用下面的方式\nt, ok := i.(string)\nif !ok {\n// 优雅地处理错误\n}\n3. 注释\n1. 在编码阶段同步写好变量、函数、包注释，注释可以通过godoc导出生成文档。\n2. 注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾。\n3. 程序中每一个被导出的(大写的)名字，都应该有一个文档注释。\n\n3.1 【必须】包注释\n\n[火箭]\n\n每个包都应该有一个包注释。\n\n[火]\n\n包如果有多个 go 文件，只需要出现在一个 go 文件中（一般是和包同名的文件）即可，格式为：\n“// Package 包名 包信息描述”。\n// Package math provides basic constants and mathematical functions.\npackage math\n// 或者\n/*\nPackage template implements data-driven templates for generating textual\noutput such as HTML.\n....\n*/\npackage template\n\n 3.2 【必须】结构体注释\n\n[火箭]\n\n每个需要导出的自定义结构体或者接口都必须有注释说明。\n\n[火]\n\n注释对结构进行简要介绍，放在结构体定义的前一行。\n\n[灯泡]\n\n格式为：\n\"// 结构体名 结构体信息描述\"。\n\n[旗子]\n\n结构体内的每个需要导出的成员变量都要有说明，该说明放在成员变量的前一行。\n\n// User 用户结构定义了用户基础信息\ntype User struct {\n  // UserName 用户名\n  UserName string\n  // Email 邮箱\n  Email string\n}\n 3.3 【必须】方法注释\n\n[火箭]\n\n每个需要导出的函数或者方法（结构体或者接口下的函数称为方法）都必须有注释。\n\n[火]\n\n注释描述函数或方法功能、调用方等信息。\n\n[灯泡]\n\n格式为：\n\"// 函数名 函数信息描述\"。\n// NewtAttrModel 是属性数据层操作类的工厂方法\nfunc NewAttrModel(ctx common.Context)AttrModel {\n  // TODO\n}\n3.4 【必须】变量注释\n\n[火箭]\n\n每个需要导出的常量和变量都必须有注释说明。\n\n[火]\n\n该注释对常量或变量进行简要介绍，放在常量或者变量定义的前一行。\n\n[灯泡]\n\n格式为：\n\"// 变量名 变量信息描述\"。\n// FlagConfigFile 配置文件的命令行参数名\nconst FlagConfigFile = \"--config\"\n// FullName 返回指定用户名的完整名称\nvar FullName = func(username string) string {\n  return fmt.Sprintf(\"fake-%s\", username)\n}\n 3.5 【必须】类型注释\n\n[火箭]\n\n每个需要导出的类型定义(type definition)和类型别名(type aliases)都必须有注释说明。\n\n[火]\n\n该注释对类型进行简要介绍，放在定义的前一行。\n\n[灯泡]\n\n格式为：\n\"// 类型名 类型信息描述\"。\n// StorageClass 存储类型\ntype StorageClass string\n// FakeTime 标准库时间的类型别名\ntype FakeTime = time.Time\n4. 命名规范\n命名是代码规范中很重要的一部分，统一的命名规范有利于提高代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。\n\n4.1 【推荐】包命名\n包命名\n[火箭] 保持package  的名字和目录一致。\n[火] 尽量采取有意义、简短的包名，尽量不要和标准库冲突。\n[灯泡] 包名应该为小写单词，不要使用下划线或者混合大小写，使用多级目录来划分层级。\n[旗子] 项目名可以通过中划线来连接多个单词。\n[火箭] 简单明了的包命名，如：time、list、http。\n[火] 不要使用无意义的包名，如：util、common、misc。\n\n 4.2 【必须】文件命名\n\n[火箭]\n\n采用有意义，简短的文件名。\n\n[火]\n\n文件名应该采用小写，并且使用下划线分割各个单词。\n\n4.3 【必须】结构体命名\n\n[火箭]\n\n采用驼峰命名方式，首字母根据访问控制采用大写或者小写。\n\n[火]\n\n结构体名应该是名词或名词短语，如\nCustomer、\nWikiPage、\nAccount、\nAddressParser。\n\n[灯泡]\n\n避免使用\nManager、\nProcessor、\nData、\nInfo\n 这样的结构体名，结构体名不应当是动词。\n\n[旗子]\n\n结构体的申明和初始化格式采用多行，例如：\n// User 多行申明\ntype User struct{\n  // Username 用户名\n  UserName string\n  // Email 电子邮件地址\n  Email string\n  }\n  // 多行初始化\n  u := User{\n  UserName: \"john\",\n  Email:    \"john@example.com\",\n}\n4.4 【推荐】接口命名\n\n[火箭]\n\n命名规则基本保持和结构体命名规则一致。\n\n[火]\n\n单个函数的结构名以 \"er\" 作为后缀，例如\nReader，Writer。\n// Reader 字节数组读取接口\ntype Reader interface {\n  // Read 读取整个给定的字节数据并返回读取的长度\n  Read(p []byte) (n int, err error)\n}\n\n[火箭]\n\n两个函数的接口名综合两个函数名。\n\n[火]\n\n三个以上函数的接口名，类似于结构体名。\n// Car 小汽车结构申明\ntype Car interface {\n  // Start ...\n  Start([]byte)\n  // Stop ...\n  Stop() error\n  // Recover ...\n  Recover()\n}\n\n4.5 【必须】变量命名\n\n[火箭]\n\n变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。\n\n[火]\n\n特有名词时，需要遵循以下规则：\n    - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient；\n    - 其他情况都应该使用该名词原有的写法，如 `APIClient`、repoID、UserID；\n    - 错误示例：UrlArray，应该写成urlArray或者URLArray；\n\n\n[火箭]\n\n若变量类型为bool类型，则名称应以Has，Is，Can或者Allow开头。\n\n[火]\n\n私有全局变量和局部变量规范一致，均以小写字母开头。\n\n4.6 【必须】常量命名\n● 常量均需遵循驼峰式。\n// AppVersion 应用程序版本号定义\nconst AppVersion = \"1.0.0\"\n\n●  如果是枚举类型的常量，需要先创建相应类型：\n// Scheme 传输协议\ntype Scheme string\nconst (\n// HTTP 表示HTTP明文传输协议\nHTTP Scheme = \"http\"\n// HTTPS 表示HTTPS加密传输协议\n)\n\n● 私有全局常量和局部变量规范一致，均以小写字母开头。\nconst appVersion = \"1.0.0\"\n5. 控制结构\n 5.1  【推荐】if\n● if 接受初始化语句，约定如下方式建立局部变量：\nif err := file.Chmod(0664); err != nil {\n  return err\n}\n 5.2    【推荐】for\n●  采用短声明建立局部变量：\nsum := 0\nfor i := 0; i < 10; i++ {\n  sum += 1\n}\n 5.3    【必须】range\n●  如果只需要第一项（key），就丢弃第二个：\n\nfor key := range m {\nif key.expired() {\n    delete(m, key)\n  }\n}\n● 如果只需要第二项，则把第一项置为下划线：\nsum := 0\nfor _, value := range array {\n  sum += value\n}\n5.4    【必须】switch\n● 要求必须有default：\nswitch os := runtime.GOOS; os {\ncase \"darwin\":\n    fmt.Println(\"OS X.\")\ncase \"linux\":\n    fmt.Println(\"Linux.\")\ndefault:\n    // freebsd, openbsd,\n    // plan9, windows...\n    fmt.Printf(\"%s.\\n\", os)\n  }\n5.5 【推荐】return\n●  尽早return，一旦有错误发生，马上返回：\nf, err := os.Open(name)\nif err != nil {\n  return err\n}\nd, err := f.Stat()\nif err != nil {\n  f.Close()\n  return err\n}\ncodeUsing(f, d)\n5.6 【必须】goto\n● 业务代码禁止使用goto，其他框架或底层源码推荐尽量不用\n\n6. 函数\n6.1 【推荐】函数参数\n● 函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其它情况不建议使用命名返回。\n// Parent1 ...\nfunc (n Node) Parent1()Node\n// Parent2 ...\nfunc (n Node) Parent2() (Node, error)\n// Location ...\nfunc (f *Foo) Location() (lat, long float64, err error)\n\n[火箭]\n\n传入变量和返回变量以小写字母开头。\n\n[火]\n\n参数数量均不能超过 5 个。\n\n[灯泡]\n\n尽量用值传递，非指针传递。\n\n[旗子]\n\n传入参数是map，slice，\nchan，\ninterface不要传递指针。\n\n 6.2 【必须】defer\n\n[火箭]\n\n当存在资源管理时，应紧跟defer函数进行资源的释放。\n\n[火]\n\n判断是否有错误发生之后，再defer释放资源。\nresp, err := http.Get(url)\nif err != nil {\n  return err\n}\n// 如果操作成功，再defer Close()\ndefer resp.Body.Close()\n● 禁止在循环中使用defer，举例如下：\n// 不要这样使用\nfunc filterSomething(values []string) {\nfor _, v := range values {\n    fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\n    if err != nil {\n        // xxx\n    }\n    defer fields.Close()\n    // 继续使用fields\n  }\n}\n// 应当使用如下的方式：\nfunc filterSomething(values []string) {\n  for _, v := range values {\n    func() {\n        fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\n        if err != nil {\n        ...\n        }\n        defer fields.Close()\n        // 继续使用fields\n    }()\n  }\n}\n 6.3 【必须】方法的接收器\n\n[火箭]\n\n接收器的命名在函数超过 20 行的时候不要用单字符。\n\n[火]\n\n命名不能采用me，this，self这类易混淆名称。\n\n6.4 【推荐】代码行数\n\n[火箭]\n\n【必须】文件长度不能超过 800 行。\n\n[火]\n\n【推荐】函数长度不能超过 80 行。\n 6.5 【必须】嵌套\n● 嵌套深度不能超过 4 层：\n// AddArea 添加成功或出错\nfunc (s *BookingService) AddArea(areas ...string) error {\n  s.Lock()\n  defer s.Unlock()\n  \n  for _, area := range areas {\n      for _, has := range s.areas {\n          if area == has {\n              return srverr.ErrAreaConflict\n          }\n      }\n      s.areas = append(s.areas, area)\n      s.areaOrders[area] = new(order.AreaOrder)\n    }\n  return nil\n}\n\n// 建议调整为这样：\n// AddArea 添加成功或出错\nfunc (s *BookingService) AddArea(areas ...string) error {\n  s.Lock()\n  defer s.Unlock()\n  \n  for _, area := range areas {\n      if s.HasArea(area) {\n          return srverr.ErrAreaConflict\n      }\n      s.areas = append(s.areas, area)\n      s.areaOrders[area] = new(order.AreaOrder)\n  }\n  return nil\n}\n\n// HasArea ...\nfunc (s *BookingService) HasArea(area string) bool {\n  for _, has := range s.areas {\n      if area == has {\n          return true\n      }\n    }\n    return false\n}\n6.6 【推荐】变量声明\n● 变量声明尽量放在变量第一次使用前面，就近原则。\n\n6.7 【必须】魔法数字\n● 如果魔法数字出现超过 2 次，则禁止使用。\nfunc getArea(r float64) float64 {\n  return 3.14 * r * r\n}\n\nfunc getLength(r float64) float64 {\n  return 3.14 * 2 * r\n}\n\n// PI ...\nconst PI = 3.14\nfunc getArea(r float64) float64 {\n  return PI * r * r\n}\n\nfunc getLength(r float64) float64 {\n  return PI * 2 * r\n}\n7. 依赖管理\n 7.1 【必须】go1.11以上必须使用 go modules模式：\ngo mod init github.com/group/myrepo\n7.2 【推荐】代码提交\n\n[火箭]\n\n建议所有不对外开源的工程的\nmodule name使用\ngithub.com/group/repo，方便他人直接引用\n\n[火]\n\n建议使用go modules作为依赖管理的项目不提交vendor目录\n\n[灯泡]\n\n建议使用go modules管理依赖的项目将go.sum文件不添加到忽略提交规则中\n8. 应用服务\n8.1 【推荐】应用服务接口建议有readme.md\n● 其中建议包括服务基本描述、使用方法、部署时的限制与要求、基础环境依赖（例如最低 go 版本、最低外部通用包版本）等。\n8.2 【必须】应用服务必须要有接口测试。\n附：常用工具\ngo 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范。\n\n[火箭]\n\ngofmt，大部分的格式问题可以通过\ngofmt解决，\ngofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以\ngofmt 的结果为准。\n\n[火]\n\ngoimports ，此工具在gofmt 的基础上增加了自动删除和引入包。\n\n[灯泡]\n\ngo vet ，vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。编译前先执行代码静态分析。\n\n[旗子]\n\ngolint ，类似javascript中的\njslint的工具，主要功能就是检测代码中不规范的地方。\n",
  "annotations": "{\n  \"decision\": \"needs-revision\",\n  \"comments\": [\n    {\n      \"type\": \"selection\",\n      \"comment\": \"可以将 代码规范 放进去：\\n\\n Golang 代码规范\\n1. 前言\\n为形成公司统一的 Go 编码风格，以保障公司项目代码的易维护性和编码安全性，特制定本规范。\\n每项规范内容，给出了要求等级，其定义为：\\n\\n[火箭]\\n\\n必须（Mandatory）：用户必须采用。\\n\\n[火]\\n\\n推荐（Preferable）：用户理应采用，但如有特殊情况，可以不采用。\\n\\n[灯泡]\\n\\n可选（Optional）：用户可参考，自行决定是否采用。\\n2. 代码风格\\n2.1 【必须】格式化\\n● 代码都必须用gofmt格式化。\\n2.2 【推荐】换行\\n● 建议一行代码不要超过 120 列，超过的情况，使用合理的换行方法换行。\\n2.3 【必须】括号和空格\\n\\n[火箭]\\n\\n遵循gofmt的逻辑。\\n\\n[火]\\n\\n运算符和操作数之间要留空格。\\n\\n[灯泡]\\n\\n作为输入参数或者数组下标时，运算符和运算数之间不需要空格，紧凑展示。\\n2.4 【必须】import规范\\n\\n[火箭]\\n\\n使用goimports自动格式化引入的包名。\\n\\n[火]\\n\\n引入单个包，也使用括号包裹。\\n// 应该采用如下格式：\\nimport (\\\"fmt\\\")\\n// 而不是这样：\\nimport \\\"fmt\\\"\\n\\n[火箭]\\n\\n 如果你引入了多种类型的包，必须对包进行分组管理，将包分为标准库包、程序内部包、第三方包，并将标准库作为第一组，三组包用空行间隔。\\n\\n[火]\\n\\ngoimports或者\\ngofmt会自动把依赖包按首字母排序。\\n\\n[灯泡]\\n\\n匿名包的引用必须使用一个新的分组引入。\\n\\n[旗子]\\n\\n不要使用相对路径引入包。\\n\\n// 不要采用这种方式\\nimport (\\n  \\\"../net\\\"\\n)\\n● 应该使用完整的路径引入包：\\nimport (\\n  \\\"xxxx.com/proj/net\\\"\\n)\\n● 包名和git 路径名不一致时，使用别名代替\\nimport (\\n  opentracing \\\"github.com/opentracing/opentracing-go\\\"\\n)\\n\\n[火箭]\\n\\n【推荐】在匿名引入的每个包上推荐写上注释说明。\\n\\n[火]\\n\\n应该采用如下方式进行组织你的包。\\nimport (\\n  // standard package\\n\\\"encoding/json\\\"\\n\\\"strings\\\"\\n\\n// inner package\\n\\\"myproject/models\\\"\\n\\\"myproject/controller\\\"\\n\\n// third-party package\\n\\\"git.obc.im/obc/utils\\\"\\n\\\"git.obc.im/dep/beego\\\"\\n\\\"git.obc.im/dep/mysql\\\"\\n\\n// alias package\\nopentracing \\\"github.com/opentracing/opentracing-go\\\"\\n\\n// anonymous import package\\n// import filesystem storage driver\\n_ \\\"github.com/org/repo/pkg/storage/filesystem\\n)\\n\\n2.5 【必须】错误处理\\n2.5.1 【必须】error处理\\n\\n[火箭]\\n\\nerror作为函数的值返回，必须对error进行处理, 或将返回值赋值给明确忽略。\\n\\n[火]\\n\\nerror作为函数的值返回且有多个返回值的时候，error必须是最后一个参数。\\n// 不要采用这种方式\\nfunc do() (error, int) {\\n}\\n// 要采用下面的方式\\nfunc do() (int, error) {\\n}\\n\\n[火箭]\\n\\n错误描述不需要标点结尾。\\n\\n[火]\\n\\n采用独立的错误流进行处理。\\n// 不要采用这种方式\\nif err != nil {\\n  // error handling\\n} else {\\n  // normal code\\n}\\n\\n// 而要采用下面的方式\\nif err != nil {\\n  // error handling\\n  return // or continue, etc.\\n}\\n// normal code\\n\\n- 如果返回值需要初始化，则采用下面的方式：\\nx, err := f()\\nif err != nil {\\n  // error handling\\n  return // or continue, etc.\\n}\\n// use x\\n\\n●  错误返回的判断独立处理，不与其他变量组合逻辑判断。\\n// 不要采用这种方式：\\nx, y, err := f()\\nif err != nil || y == nil {\\n  return err   // 当y与err都为空时，函数的调用者会出现错误的调用逻辑\\n}\\n\\n// 应当使用如下方式：\\nx, y, err := f()\\nif err != nil {\\n  return err\\n}\\nif y == nil {\\n  return fmt.Errorf(\\\"some error\\\")\\n}\\n● 【推荐】建议 go1.13 以上，error 生成方式为：fmt.Errorf(\\\"module xxx: %w\\\", err)\\n\\n 2.5.2 【必须】panic 处理\\nPANIC\\n[火箭] 在业务逻辑处理中禁止使用panic。\\n[火] 在main包中只有当完全不可运行的情况可使用panic，例如：文件无法打开，数据库无法连接导致程序无法正常运行。\\n[灯泡] 对于其它的包，可导出的接口不能有panic，只能在包内使用。\\n[旗子] 建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。\\n[火箭]panic捕获只能到goroutine最顶层，每个自行启动的goroutine，必须在入口处捕获panic，并打印详细堆栈信息或进行其它处理。\\n2.5.3 【必须】recover处理\\n\\n[火箭]\\n\\nrecover 用于捕获runtime的异常，禁止滥用recover。\\n\\n[火]\\n\\n必须在defer中使用，一般用来捕获程序运行期间发生异常抛出的panic或程序主动抛出的\\npanic。\\npackage main\\nimport (\\n  \\\"log\\\"\\n)\\nfunc main() {\\n  defer func() {\\n      if err := recover(); err != nil {\\n          // do something or record log\\n      log.Println(\\\"exec panic error: \\\", err)\\n          // log.Println(debug.Stack())\\n      }\\n  }()\\n  \\n  getOne()\\n  \\n  panic(11) //手动抛出panic\\n}\\n// getOne 模拟slice越界 runtime运行时抛出的panic\\nfunc getOne() {\\n  defer func() {\\n      if err := recover(); err != nil {\\n          // do something or record log\\n      log.Println(\\\"exec panic error: \\\", err)\\n          // log.Println(debug.Stack())\\n      }\\n  }()\\n  \\n  var arr = []string{\\\"a\\\", \\\"b\\\", \\\"c\\\"}\\n  log.Println(\\\"hello,\\\", arr[4])\\n}\\n\\n// 执行结果：\\n// 2020/01/02 17:18:53 exec panic error:  runtime error: index out of range\\n// 2020/01/02 17:18:53 exec panic error:  11\\n\\n2.6 【必须】单元测试\\n\\n[火箭]\\n\\n单元测试文件名命名规范为\\nexample_test.go。\\n\\n[火]\\n\\n测试用例的函数名称必须以\\nTest开头，例如\\nTestExample。\\n\\n[灯泡]\\n\\n每个重要的可导出函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试。\\n2.7 【必须】类型断言失败处理\\n● type assertion的单个返回值形式针对不正确的类型将产生panic。因此，请始终使用“comma ok”的惯用法。\\n// 不要采用这种方式\\nt := i.(string)\\n// 而要采用下面的方式\\nt, ok := i.(string)\\nif !ok {\\n// 优雅地处理错误\\n}\\n3. 注释\\n1. 在编码阶段同步写好变量、函数、包注释，注释可以通过godoc导出生成文档。\\n2. 注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾。\\n3. 程序中每一个被导出的(大写的)名字，都应该有一个文档注释。\\n\\n3.1 【必须】包注释\\n\\n[火箭]\\n\\n每个包都应该有一个包注释。\\n\\n[火]\\n\\n包如果有多个 go 文件，只需要出现在一个 go 文件中（一般是和包同名的文件）即可，格式为：\\n“// Package 包名 包信息描述”。\\n// Package math provides basic constants and mathematical functions.\\npackage math\\n// 或者\\n/*\\nPackage template implements data-driven templates for generating textual\\noutput such as HTML.\\n....\\n*/\\npackage template\\n\\n 3.2 【必须】结构体注释\\n\\n[火箭]\\n\\n每个需要导出的自定义结构体或者接口都必须有注释说明。\\n\\n[火]\\n\\n注释对结构进行简要介绍，放在结构体定义的前一行。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 结构体名 结构体信息描述\\\"。\\n\\n[旗子]\\n\\n结构体内的每个需要导出的成员变量都要有说明，该说明放在成员变量的前一行。\\n\\n// User 用户结构定义了用户基础信息\\ntype User struct {\\n  // UserName 用户名\\n  UserName string\\n  // Email 邮箱\\n  Email string\\n}\\n 3.3 【必须】方法注释\\n\\n[火箭]\\n\\n每个需要导出的函数或者方法（结构体或者接口下的函数称为方法）都必须有注释。\\n\\n[火]\\n\\n注释描述函数或方法功能、调用方等信息。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 函数名 函数信息描述\\\"。\\n// NewtAttrModel 是属性数据层操作类的工厂方法\\nfunc NewAttrModel(ctx common.Context)AttrModel {\\n  // TODO\\n}\\n3.4 【必须】变量注释\\n\\n[火箭]\\n\\n每个需要导出的常量和变量都必须有注释说明。\\n\\n[火]\\n\\n该注释对常量或变量进行简要介绍，放在常量或者变量定义的前一行。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 变量名 变量信息描述\\\"。\\n// FlagConfigFile 配置文件的命令行参数名\\nconst FlagConfigFile = \\\"--config\\\"\\n// FullName 返回指定用户名的完整名称\\nvar FullName = func(username string) string {\\n  return fmt.Sprintf(\\\"fake-%s\\\", username)\\n}\\n 3.5 【必须】类型注释\\n\\n[火箭]\\n\\n每个需要导出的类型定义(type definition)和类型别名(type aliases)都必须有注释说明。\\n\\n[火]\\n\\n该注释对类型进行简要介绍，放在定义的前一行。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 类型名 类型信息描述\\\"。\\n// StorageClass 存储类型\\ntype StorageClass string\\n// FakeTime 标准库时间的类型别名\\ntype FakeTime = time.Time\\n4. 命名规范\\n命名是代码规范中很重要的一部分，统一的命名规范有利于提高代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。\\n\\n4.1 【推荐】包命名\\n包命名\\n[火箭] 保持package  的名字和目录一致。\\n[火] 尽量采取有意义、简短的包名，尽量不要和标准库冲突。\\n[灯泡] 包名应该为小写单词，不要使用下划线或者混合大小写，使用多级目录来划分层级。\\n[旗子] 项目名可以通过中划线来连接多个单词。\\n[火箭] 简单明了的包命名，如：time、list、http。\\n[火] 不要使用无意义的包名，如：util、common、misc。\\n\\n 4.2 【必须】文件命名\\n\\n[火箭]\\n\\n采用有意义，简短的文件名。\\n\\n[火]\\n\\n文件名应该采用小写，并且使用下划线分割各个单词。\\n\\n4.3 【必须】结构体命名\\n\\n[火箭]\\n\\n采用驼峰命名方式，首字母根据访问控制采用大写或者小写。\\n\\n[火]\\n\\n结构体名应该是名词或名词短语，如\\nCustomer、\\nWikiPage、\\nAccount、\\nAddressParser。\\n\\n[灯泡]\\n\\n避免使用\\nManager、\\nProcessor、\\nData、\\nInfo\\n 这样的结构体名，结构体名不应当是动词。\\n\\n[旗子]\\n\\n结构体的申明和初始化格式采用多行，例如：\\n// User 多行申明\\ntype User struct{\\n  // Username 用户名\\n  UserName string\\n  // Email 电子邮件地址\\n  Email string\\n  }\\n  // 多行初始化\\n  u := User{\\n  UserName: \\\"john\\\",\\n  Email:    \\\"john@example.com\\\",\\n}\\n4.4 【推荐】接口命名\\n\\n[火箭]\\n\\n命名规则基本保持和结构体命名规则一致。\\n\\n[火]\\n\\n单个函数的结构名以 \\\"er\\\" 作为后缀，例如\\nReader，Writer。\\n// Reader 字节数组读取接口\\ntype Reader interface {\\n  // Read 读取整个给定的字节数据并返回读取的长度\\n  Read(p []byte) (n int, err error)\\n}\\n\\n[火箭]\\n\\n两个函数的接口名综合两个函数名。\\n\\n[火]\\n\\n三个以上函数的接口名，类似于结构体名。\\n// Car 小汽车结构申明\\ntype Car interface {\\n  // Start ...\\n  Start([]byte)\\n  // Stop ...\\n  Stop() error\\n  // Recover ...\\n  Recover()\\n}\\n\\n4.5 【必须】变量命名\\n\\n[火箭]\\n\\n变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。\\n\\n[火]\\n\\n特有名词时，需要遵循以下规则：\\n    - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient；\\n    - 其他情况都应该使用该名词原有的写法，如 `APIClient`、repoID、UserID；\\n    - 错误示例：UrlArray，应该写成urlArray或者URLArray；\\n\\n\\n[火箭]\\n\\n若变量类型为bool类型，则名称应以Has，Is，Can或者Allow开头。\\n\\n[火]\\n\\n私有全局变量和局部变量规范一致，均以小写字母开头。\\n\\n4.6 【必须】常量命名\\n● 常量均需遵循驼峰式。\\n// AppVersion 应用程序版本号定义\\nconst AppVersion = \\\"1.0.0\\\"\\n\\n●  如果是枚举类型的常量，需要先创建相应类型：\\n// Scheme 传输协议\\ntype Scheme string\\nconst (\\n// HTTP 表示HTTP明文传输协议\\nHTTP Scheme = \\\"http\\\"\\n// HTTPS 表示HTTPS加密传输协议\\n)\\n\\n● 私有全局常量和局部变量规范一致，均以小写字母开头。\\nconst appVersion = \\\"1.0.0\\\"\\n5. 控制结构\\n 5.1  【推荐】if\\n● if 接受初始化语句，约定如下方式建立局部变量：\\nif err := file.Chmod(0664); err != nil {\\n  return err\\n}\\n 5.2    【推荐】for\\n●  采用短声明建立局部变量：\\nsum := 0\\nfor i := 0; i < 10; i++ {\\n  sum += 1\\n}\\n 5.3    【必须】range\\n●  如果只需要第一项（key），就丢弃第二个：\\n\\nfor key := range m {\\nif key.expired() {\\n    delete(m, key)\\n  }\\n}\\n● 如果只需要第二项，则把第一项置为下划线：\\nsum := 0\\nfor _, value := range array {\\n  sum += value\\n}\\n5.4    【必须】switch\\n● 要求必须有default：\\nswitch os := runtime.GOOS; os {\\ncase \\\"darwin\\\":\\n    fmt.Println(\\\"OS X.\\\")\\ncase \\\"linux\\\":\\n    fmt.Println(\\\"Linux.\\\")\\ndefault:\\n    // freebsd, openbsd,\\n    // plan9, windows...\\n    fmt.Printf(\\\"%s.\\\\n\\\", os)\\n  }\\n5.5 【推荐】return\\n●  尽早return，一旦有错误发生，马上返回：\\nf, err := os.Open(name)\\nif err != nil {\\n  return err\\n}\\nd, err := f.Stat()\\nif err != nil {\\n  f.Close()\\n  return err\\n}\\ncodeUsing(f, d)\\n5.6 【必须】goto\\n● 业务代码禁止使用goto，其他框架或底层源码推荐尽量不用\\n\\n6. 函数\\n6.1 【推荐】函数参数\\n● 函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其它情况不建议使用命名返回。\\n// Parent1 ...\\nfunc (n Node) Parent1()Node\\n// Parent2 ...\\nfunc (n Node) Parent2() (Node, error)\\n// Location ...\\nfunc (f *Foo) Location() (lat, long float64, err error)\\n\\n[火箭]\\n\\n传入变量和返回变量以小写字母开头。\\n\\n[火]\\n\\n参数数量均不能超过 5 个。\\n\\n[灯泡]\\n\\n尽量用值传递，非指针传递。\\n\\n[旗子]\\n\\n传入参数是map，slice，\\nchan，\\ninterface不要传递指针。\\n\\n 6.2 【必须】defer\\n\\n[火箭]\\n\\n当存在资源管理时，应紧跟defer函数进行资源的释放。\\n\\n[火]\\n\\n判断是否有错误发生之后，再defer释放资源。\\nresp, err := http.Get(url)\\nif err != nil {\\n  return err\\n}\\n// 如果操作成功，再defer Close()\\ndefer resp.Body.Close()\\n● 禁止在循环中使用defer，举例如下：\\n// 不要这样使用\\nfunc filterSomething(values []string) {\\nfor _, v := range values {\\n    fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\\n    if err != nil {\\n        // xxx\\n    }\\n    defer fields.Close()\\n    // 继续使用fields\\n  }\\n}\\n// 应当使用如下的方式：\\nfunc filterSomething(values []string) {\\n  for _, v := range values {\\n    func() {\\n        fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\\n        if err != nil {\\n        ...\\n        }\\n        defer fields.Close()\\n        // 继续使用fields\\n    }()\\n  }\\n}\\n 6.3 【必须】方法的接收器\\n\\n[火箭]\\n\\n接收器的命名在函数超过 20 行的时候不要用单字符。\\n\\n[火]\\n\\n命名不能采用me，this，self这类易混淆名称。\\n\\n6.4 【推荐】代码行数\\n\\n[火箭]\\n\\n【必须】文件长度不能超过 800 行。\\n\\n[火]\\n\\n【推荐】函数长度不能超过 80 行。\\n 6.5 【必须】嵌套\\n● 嵌套深度不能超过 4 层：\\n// AddArea 添加成功或出错\\nfunc (s *BookingService) AddArea(areas ...string) error {\\n  s.Lock()\\n  defer s.Unlock()\\n  \\n  for _, area := range areas {\\n      for _, has := range s.areas {\\n          if area == has {\\n              return srverr.ErrAreaConflict\\n          }\\n      }\\n      s.areas = append(s.areas, area)\\n      s.areaOrders[area] = new(order.AreaOrder)\\n    }\\n  return nil\\n}\\n\\n// 建议调整为这样：\\n// AddArea 添加成功或出错\\nfunc (s *BookingService) AddArea(areas ...string) error {\\n  s.Lock()\\n  defer s.Unlock()\\n  \\n  for _, area := range areas {\\n      if s.HasArea(area) {\\n          return srverr.ErrAreaConflict\\n      }\\n      s.areas = append(s.areas, area)\\n      s.areaOrders[area] = new(order.AreaOrder)\\n  }\\n  return nil\\n}\\n\\n// HasArea ...\\nfunc (s *BookingService) HasArea(area string) bool {\\n  for _, has := range s.areas {\\n      if area == has {\\n          return true\\n      }\\n    }\\n    return false\\n}\\n6.6 【推荐】变量声明\\n● 变量声明尽量放在变量第一次使用前面，就近原则。\\n\\n6.7 【必须】魔法数字\\n● 如果魔法数字出现超过 2 次，则禁止使用。\\nfunc getArea(r float64) float64 {\\n  return 3.14 * r * r\\n}\\n\\nfunc getLength(r float64) float64 {\\n  return 3.14 * 2 * r\\n}\\n\\n// PI ...\\nconst PI = 3.14\\nfunc getArea(r float64) float64 {\\n  return PI * r * r\\n}\\n\\nfunc getLength(r float64) float64 {\\n  return PI * 2 * r\\n}\\n7. 依赖管理\\n 7.1 【必须】go1.11以上必须使用 go modules模式：\\ngo mod init github.com/group/myrepo\\n7.2 【推荐】代码提交\\n\\n[火箭]\\n\\n建议所有不对外开源的工程的\\nmodule name使用\\ngithub.com/group/repo，方便他人直接引用\\n\\n[火]\\n\\n建议使用go modules作为依赖管理的项目不提交vendor目录\\n\\n[灯泡]\\n\\n建议使用go modules管理依赖的项目将go.sum文件不添加到忽略提交规则中\\n8. 应用服务\\n8.1 【推荐】应用服务接口建议有readme.md\\n● 其中建议包括服务基本描述、使用方法、部署时的限制与要求、基础环境依赖（例如最低 go 版本、最低外部通用包版本）等。\\n8.2 【必须】应用服务必须要有接口测试。\\n附：常用工具\\ngo 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范。\\n\\n[火箭]\\n\\ngofmt，大部分的格式问题可以通过\\ngofmt解决，\\ngofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以\\ngofmt 的结果为准。\\n\\n[火]\\n\\ngoimports ，此工具在gofmt 的基础上增加了自动删除和引入包。\\n\\n[灯泡]\\n\\ngo vet ，vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。编译前先执行代码静态分析。\\n\\n[旗子]\\n\\ngolint ，类似javascript中的\\njslint的工具，主要功能就是检测代码中不规范的地方。\",\n      \"timestamp\": \"2026-01-06T03:31:45.183Z\",\n      \"selectedText\": \"# Technology Stack\",\n      \"highlightColor\": {\n        \"bg\": \"rgba(255, 235, 59, 0.3)\",\n        \"border\": \"#FFEB3B\",\n        \"name\": \"#ffeb3b\"\n      },\n      \"id\": \"comment_1767670305183_wekn04m05\",\n      \"startOffset\": 0,\n      \"endOffset\": 18\n    }\n  ],\n  \"summary\": \"Feedback Summary (1 comments):\\n\\nSpecific Text Comments:\\n1. \\\"# Technology Stack\\\": 可以将 代码规范 放进去：\\n\\n Golang 代码规范\\n1. 前言\\n为形成公司统一的 Go 编码风格，以保障公司项目代码的易维护性和编码安全性，特制定本规范。\\n每项规范内容，给出了要求等级，其定义为：\\n\\n[火箭]\\n\\n必须（Mandatory）：用户必须采用。\\n\\n[火]\\n\\n推荐（Preferable）：用户理应采用，但如有特殊情况，可以不采用。\\n\\n[灯泡]\\n\\n可选（Optional）：用户可参考，自行决定是否采用。\\n2. 代码风格\\n2.1 【必须】格式化\\n● 代码都必须用gofmt格式化。\\n2.2 【推荐】换行\\n● 建议一行代码不要超过 120 列，超过的情况，使用合理的换行方法换行。\\n2.3 【必须】括号和空格\\n\\n[火箭]\\n\\n遵循gofmt的逻辑。\\n\\n[火]\\n\\n运算符和操作数之间要留空格。\\n\\n[灯泡]\\n\\n作为输入参数或者数组下标时，运算符和运算数之间不需要空格，紧凑展示。\\n2.4 【必须】import规范\\n\\n[火箭]\\n\\n使用goimports自动格式化引入的包名。\\n\\n[火]\\n\\n引入单个包，也使用括号包裹。\\n// 应该采用如下格式：\\nimport (\\\"fmt\\\")\\n// 而不是这样：\\nimport \\\"fmt\\\"\\n\\n[火箭]\\n\\n 如果你引入了多种类型的包，必须对包进行分组管理，将包分为标准库包、程序内部包、第三方包，并将标准库作为第一组，三组包用空行间隔。\\n\\n[火]\\n\\ngoimports或者\\ngofmt会自动把依赖包按首字母排序。\\n\\n[灯泡]\\n\\n匿名包的引用必须使用一个新的分组引入。\\n\\n[旗子]\\n\\n不要使用相对路径引入包。\\n\\n// 不要采用这种方式\\nimport (\\n  \\\"../net\\\"\\n)\\n● 应该使用完整的路径引入包：\\nimport (\\n  \\\"xxxx.com/proj/net\\\"\\n)\\n● 包名和git 路径名不一致时，使用别名代替\\nimport (\\n  opentracing \\\"github.com/opentracing/opentracing-go\\\"\\n)\\n\\n[火箭]\\n\\n【推荐】在匿名引入的每个包上推荐写上注释说明。\\n\\n[火]\\n\\n应该采用如下方式进行组织你的包。\\nimport (\\n  // standard package\\n\\\"encoding/json\\\"\\n\\\"strings\\\"\\n\\n// inner package\\n\\\"myproject/models\\\"\\n\\\"myproject/controller\\\"\\n\\n// third-party package\\n\\\"git.obc.im/obc/utils\\\"\\n\\\"git.obc.im/dep/beego\\\"\\n\\\"git.obc.im/dep/mysql\\\"\\n\\n// alias package\\nopentracing \\\"github.com/opentracing/opentracing-go\\\"\\n\\n// anonymous import package\\n// import filesystem storage driver\\n_ \\\"github.com/org/repo/pkg/storage/filesystem\\n)\\n\\n2.5 【必须】错误处理\\n2.5.1 【必须】error处理\\n\\n[火箭]\\n\\nerror作为函数的值返回，必须对error进行处理, 或将返回值赋值给明确忽略。\\n\\n[火]\\n\\nerror作为函数的值返回且有多个返回值的时候，error必须是最后一个参数。\\n// 不要采用这种方式\\nfunc do() (error, int) {\\n}\\n// 要采用下面的方式\\nfunc do() (int, error) {\\n}\\n\\n[火箭]\\n\\n错误描述不需要标点结尾。\\n\\n[火]\\n\\n采用独立的错误流进行处理。\\n// 不要采用这种方式\\nif err != nil {\\n  // error handling\\n} else {\\n  // normal code\\n}\\n\\n// 而要采用下面的方式\\nif err != nil {\\n  // error handling\\n  return // or continue, etc.\\n}\\n// normal code\\n\\n- 如果返回值需要初始化，则采用下面的方式：\\nx, err := f()\\nif err != nil {\\n  // error handling\\n  return // or continue, etc.\\n}\\n// use x\\n\\n●  错误返回的判断独立处理，不与其他变量组合逻辑判断。\\n// 不要采用这种方式：\\nx, y, err := f()\\nif err != nil || y == nil {\\n  return err   // 当y与err都为空时，函数的调用者会出现错误的调用逻辑\\n}\\n\\n// 应当使用如下方式：\\nx, y, err := f()\\nif err != nil {\\n  return err\\n}\\nif y == nil {\\n  return fmt.Errorf(\\\"some error\\\")\\n}\\n● 【推荐】建议 go1.13 以上，error 生成方式为：fmt.Errorf(\\\"module xxx: %w\\\", err)\\n\\n 2.5.2 【必须】panic 处理\\nPANIC\\n[火箭] 在业务逻辑处理中禁止使用panic。\\n[火] 在main包中只有当完全不可运行的情况可使用panic，例如：文件无法打开，数据库无法连接导致程序无法正常运行。\\n[灯泡] 对于其它的包，可导出的接口不能有panic，只能在包内使用。\\n[旗子] 建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。\\n[火箭]panic捕获只能到goroutine最顶层，每个自行启动的goroutine，必须在入口处捕获panic，并打印详细堆栈信息或进行其它处理。\\n2.5.3 【必须】recover处理\\n\\n[火箭]\\n\\nrecover 用于捕获runtime的异常，禁止滥用recover。\\n\\n[火]\\n\\n必须在defer中使用，一般用来捕获程序运行期间发生异常抛出的panic或程序主动抛出的\\npanic。\\npackage main\\nimport (\\n  \\\"log\\\"\\n)\\nfunc main() {\\n  defer func() {\\n      if err := recover(); err != nil {\\n          // do something or record log\\n      log.Println(\\\"exec panic error: \\\", err)\\n          // log.Println(debug.Stack())\\n      }\\n  }()\\n  \\n  getOne()\\n  \\n  panic(11) //手动抛出panic\\n}\\n// getOne 模拟slice越界 runtime运行时抛出的panic\\nfunc getOne() {\\n  defer func() {\\n      if err := recover(); err != nil {\\n          // do something or record log\\n      log.Println(\\\"exec panic error: \\\", err)\\n          // log.Println(debug.Stack())\\n      }\\n  }()\\n  \\n  var arr = []string{\\\"a\\\", \\\"b\\\", \\\"c\\\"}\\n  log.Println(\\\"hello,\\\", arr[4])\\n}\\n\\n// 执行结果：\\n// 2020/01/02 17:18:53 exec panic error:  runtime error: index out of range\\n// 2020/01/02 17:18:53 exec panic error:  11\\n\\n2.6 【必须】单元测试\\n\\n[火箭]\\n\\n单元测试文件名命名规范为\\nexample_test.go。\\n\\n[火]\\n\\n测试用例的函数名称必须以\\nTest开头，例如\\nTestExample。\\n\\n[灯泡]\\n\\n每个重要的可导出函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试。\\n2.7 【必须】类型断言失败处理\\n● type assertion的单个返回值形式针对不正确的类型将产生panic。因此，请始终使用“comma ok”的惯用法。\\n// 不要采用这种方式\\nt := i.(string)\\n// 而要采用下面的方式\\nt, ok := i.(string)\\nif !ok {\\n// 优雅地处理错误\\n}\\n3. 注释\\n1. 在编码阶段同步写好变量、函数、包注释，注释可以通过godoc导出生成文档。\\n2. 注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾。\\n3. 程序中每一个被导出的(大写的)名字，都应该有一个文档注释。\\n\\n3.1 【必须】包注释\\n\\n[火箭]\\n\\n每个包都应该有一个包注释。\\n\\n[火]\\n\\n包如果有多个 go 文件，只需要出现在一个 go 文件中（一般是和包同名的文件）即可，格式为：\\n“// Package 包名 包信息描述”。\\n// Package math provides basic constants and mathematical functions.\\npackage math\\n// 或者\\n/*\\nPackage template implements data-driven templates for generating textual\\noutput such as HTML.\\n....\\n*/\\npackage template\\n\\n 3.2 【必须】结构体注释\\n\\n[火箭]\\n\\n每个需要导出的自定义结构体或者接口都必须有注释说明。\\n\\n[火]\\n\\n注释对结构进行简要介绍，放在结构体定义的前一行。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 结构体名 结构体信息描述\\\"。\\n\\n[旗子]\\n\\n结构体内的每个需要导出的成员变量都要有说明，该说明放在成员变量的前一行。\\n\\n// User 用户结构定义了用户基础信息\\ntype User struct {\\n  // UserName 用户名\\n  UserName string\\n  // Email 邮箱\\n  Email string\\n}\\n 3.3 【必须】方法注释\\n\\n[火箭]\\n\\n每个需要导出的函数或者方法（结构体或者接口下的函数称为方法）都必须有注释。\\n\\n[火]\\n\\n注释描述函数或方法功能、调用方等信息。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 函数名 函数信息描述\\\"。\\n// NewtAttrModel 是属性数据层操作类的工厂方法\\nfunc NewAttrModel(ctx common.Context)AttrModel {\\n  // TODO\\n}\\n3.4 【必须】变量注释\\n\\n[火箭]\\n\\n每个需要导出的常量和变量都必须有注释说明。\\n\\n[火]\\n\\n该注释对常量或变量进行简要介绍，放在常量或者变量定义的前一行。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 变量名 变量信息描述\\\"。\\n// FlagConfigFile 配置文件的命令行参数名\\nconst FlagConfigFile = \\\"--config\\\"\\n// FullName 返回指定用户名的完整名称\\nvar FullName = func(username string) string {\\n  return fmt.Sprintf(\\\"fake-%s\\\", username)\\n}\\n 3.5 【必须】类型注释\\n\\n[火箭]\\n\\n每个需要导出的类型定义(type definition)和类型别名(type aliases)都必须有注释说明。\\n\\n[火]\\n\\n该注释对类型进行简要介绍，放在定义的前一行。\\n\\n[灯泡]\\n\\n格式为：\\n\\\"// 类型名 类型信息描述\\\"。\\n// StorageClass 存储类型\\ntype StorageClass string\\n// FakeTime 标准库时间的类型别名\\ntype FakeTime = time.Time\\n4. 命名规范\\n命名是代码规范中很重要的一部分，统一的命名规范有利于提高代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。\\n\\n4.1 【推荐】包命名\\n包命名\\n[火箭] 保持package  的名字和目录一致。\\n[火] 尽量采取有意义、简短的包名，尽量不要和标准库冲突。\\n[灯泡] 包名应该为小写单词，不要使用下划线或者混合大小写，使用多级目录来划分层级。\\n[旗子] 项目名可以通过中划线来连接多个单词。\\n[火箭] 简单明了的包命名，如：time、list、http。\\n[火] 不要使用无意义的包名，如：util、common、misc。\\n\\n 4.2 【必须】文件命名\\n\\n[火箭]\\n\\n采用有意义，简短的文件名。\\n\\n[火]\\n\\n文件名应该采用小写，并且使用下划线分割各个单词。\\n\\n4.3 【必须】结构体命名\\n\\n[火箭]\\n\\n采用驼峰命名方式，首字母根据访问控制采用大写或者小写。\\n\\n[火]\\n\\n结构体名应该是名词或名词短语，如\\nCustomer、\\nWikiPage、\\nAccount、\\nAddressParser。\\n\\n[灯泡]\\n\\n避免使用\\nManager、\\nProcessor、\\nData、\\nInfo\\n 这样的结构体名，结构体名不应当是动词。\\n\\n[旗子]\\n\\n结构体的申明和初始化格式采用多行，例如：\\n// User 多行申明\\ntype User struct{\\n  // Username 用户名\\n  UserName string\\n  // Email 电子邮件地址\\n  Email string\\n  }\\n  // 多行初始化\\n  u := User{\\n  UserName: \\\"john\\\",\\n  Email:    \\\"john@example.com\\\",\\n}\\n4.4 【推荐】接口命名\\n\\n[火箭]\\n\\n命名规则基本保持和结构体命名规则一致。\\n\\n[火]\\n\\n单个函数的结构名以 \\\"er\\\" 作为后缀，例如\\nReader，Writer。\\n// Reader 字节数组读取接口\\ntype Reader interface {\\n  // Read 读取整个给定的字节数据并返回读取的长度\\n  Read(p []byte) (n int, err error)\\n}\\n\\n[火箭]\\n\\n两个函数的接口名综合两个函数名。\\n\\n[火]\\n\\n三个以上函数的接口名，类似于结构体名。\\n// Car 小汽车结构申明\\ntype Car interface {\\n  // Start ...\\n  Start([]byte)\\n  // Stop ...\\n  Stop() error\\n  // Recover ...\\n  Recover()\\n}\\n\\n4.5 【必须】变量命名\\n\\n[火箭]\\n\\n变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。\\n\\n[火]\\n\\n特有名词时，需要遵循以下规则：\\n    - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient；\\n    - 其他情况都应该使用该名词原有的写法，如 `APIClient`、repoID、UserID；\\n    - 错误示例：UrlArray，应该写成urlArray或者URLArray；\\n\\n\\n[火箭]\\n\\n若变量类型为bool类型，则名称应以Has，Is，Can或者Allow开头。\\n\\n[火]\\n\\n私有全局变量和局部变量规范一致，均以小写字母开头。\\n\\n4.6 【必须】常量命名\\n● 常量均需遵循驼峰式。\\n// AppVersion 应用程序版本号定义\\nconst AppVersion = \\\"1.0.0\\\"\\n\\n●  如果是枚举类型的常量，需要先创建相应类型：\\n// Scheme 传输协议\\ntype Scheme string\\nconst (\\n// HTTP 表示HTTP明文传输协议\\nHTTP Scheme = \\\"http\\\"\\n// HTTPS 表示HTTPS加密传输协议\\n)\\n\\n● 私有全局常量和局部变量规范一致，均以小写字母开头。\\nconst appVersion = \\\"1.0.0\\\"\\n5. 控制结构\\n 5.1  【推荐】if\\n● if 接受初始化语句，约定如下方式建立局部变量：\\nif err := file.Chmod(0664); err != nil {\\n  return err\\n}\\n 5.2    【推荐】for\\n●  采用短声明建立局部变量：\\nsum := 0\\nfor i := 0; i < 10; i++ {\\n  sum += 1\\n}\\n 5.3    【必须】range\\n●  如果只需要第一项（key），就丢弃第二个：\\n\\nfor key := range m {\\nif key.expired() {\\n    delete(m, key)\\n  }\\n}\\n● 如果只需要第二项，则把第一项置为下划线：\\nsum := 0\\nfor _, value := range array {\\n  sum += value\\n}\\n5.4    【必须】switch\\n● 要求必须有default：\\nswitch os := runtime.GOOS; os {\\ncase \\\"darwin\\\":\\n    fmt.Println(\\\"OS X.\\\")\\ncase \\\"linux\\\":\\n    fmt.Println(\\\"Linux.\\\")\\ndefault:\\n    // freebsd, openbsd,\\n    // plan9, windows...\\n    fmt.Printf(\\\"%s.\\\\n\\\", os)\\n  }\\n5.5 【推荐】return\\n●  尽早return，一旦有错误发生，马上返回：\\nf, err := os.Open(name)\\nif err != nil {\\n  return err\\n}\\nd, err := f.Stat()\\nif err != nil {\\n  f.Close()\\n  return err\\n}\\ncodeUsing(f, d)\\n5.6 【必须】goto\\n● 业务代码禁止使用goto，其他框架或底层源码推荐尽量不用\\n\\n6. 函数\\n6.1 【推荐】函数参数\\n● 函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其它情况不建议使用命名返回。\\n// Parent1 ...\\nfunc (n Node) Parent1()Node\\n// Parent2 ...\\nfunc (n Node) Parent2() (Node, error)\\n// Location ...\\nfunc (f *Foo) Location() (lat, long float64, err error)\\n\\n[火箭]\\n\\n传入变量和返回变量以小写字母开头。\\n\\n[火]\\n\\n参数数量均不能超过 5 个。\\n\\n[灯泡]\\n\\n尽量用值传递，非指针传递。\\n\\n[旗子]\\n\\n传入参数是map，slice，\\nchan，\\ninterface不要传递指针。\\n\\n 6.2 【必须】defer\\n\\n[火箭]\\n\\n当存在资源管理时，应紧跟defer函数进行资源的释放。\\n\\n[火]\\n\\n判断是否有错误发生之后，再defer释放资源。\\nresp, err := http.Get(url)\\nif err != nil {\\n  return err\\n}\\n// 如果操作成功，再defer Close()\\ndefer resp.Body.Close()\\n● 禁止在循环中使用defer，举例如下：\\n// 不要这样使用\\nfunc filterSomething(values []string) {\\nfor _, v := range values {\\n    fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\\n    if err != nil {\\n        // xxx\\n    }\\n    defer fields.Close()\\n    // 继续使用fields\\n  }\\n}\\n// 应当使用如下的方式：\\nfunc filterSomething(values []string) {\\n  for _, v := range values {\\n    func() {\\n        fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\\n        if err != nil {\\n        ...\\n        }\\n        defer fields.Close()\\n        // 继续使用fields\\n    }()\\n  }\\n}\\n 6.3 【必须】方法的接收器\\n\\n[火箭]\\n\\n接收器的命名在函数超过 20 行的时候不要用单字符。\\n\\n[火]\\n\\n命名不能采用me，this，self这类易混淆名称。\\n\\n6.4 【推荐】代码行数\\n\\n[火箭]\\n\\n【必须】文件长度不能超过 800 行。\\n\\n[火]\\n\\n【推荐】函数长度不能超过 80 行。\\n 6.5 【必须】嵌套\\n● 嵌套深度不能超过 4 层：\\n// AddArea 添加成功或出错\\nfunc (s *BookingService) AddArea(areas ...string) error {\\n  s.Lock()\\n  defer s.Unlock()\\n  \\n  for _, area := range areas {\\n      for _, has := range s.areas {\\n          if area == has {\\n              return srverr.ErrAreaConflict\\n          }\\n      }\\n      s.areas = append(s.areas, area)\\n      s.areaOrders[area] = new(order.AreaOrder)\\n    }\\n  return nil\\n}\\n\\n// 建议调整为这样：\\n// AddArea 添加成功或出错\\nfunc (s *BookingService) AddArea(areas ...string) error {\\n  s.Lock()\\n  defer s.Unlock()\\n  \\n  for _, area := range areas {\\n      if s.HasArea(area) {\\n          return srverr.ErrAreaConflict\\n      }\\n      s.areas = append(s.areas, area)\\n      s.areaOrders[area] = new(order.AreaOrder)\\n  }\\n  return nil\\n}\\n\\n// HasArea ...\\nfunc (s *BookingService) HasArea(area string) bool {\\n  for _, has := range s.areas {\\n      if area == has {\\n          return true\\n      }\\n    }\\n    return false\\n}\\n6.6 【推荐】变量声明\\n● 变量声明尽量放在变量第一次使用前面，就近原则。\\n\\n6.7 【必须】魔法数字\\n● 如果魔法数字出现超过 2 次，则禁止使用。\\nfunc getArea(r float64) float64 {\\n  return 3.14 * r * r\\n}\\n\\nfunc getLength(r float64) float64 {\\n  return 3.14 * 2 * r\\n}\\n\\n// PI ...\\nconst PI = 3.14\\nfunc getArea(r float64) float64 {\\n  return PI * r * r\\n}\\n\\nfunc getLength(r float64) float64 {\\n  return PI * 2 * r\\n}\\n7. 依赖管理\\n 7.1 【必须】go1.11以上必须使用 go modules模式：\\ngo mod init github.com/group/myrepo\\n7.2 【推荐】代码提交\\n\\n[火箭]\\n\\n建议所有不对外开源的工程的\\nmodule name使用\\ngithub.com/group/repo，方便他人直接引用\\n\\n[火]\\n\\n建议使用go modules作为依赖管理的项目不提交vendor目录\\n\\n[灯泡]\\n\\n建议使用go modules管理依赖的项目将go.sum文件不添加到忽略提交规则中\\n8. 应用服务\\n8.1 【推荐】应用服务接口建议有readme.md\\n● 其中建议包括服务基本描述、使用方法、部署时的限制与要求、基础环境依赖（例如最低 go 版本、最低外部通用包版本）等。\\n8.2 【必须】应用服务必须要有接口测试。\\n附：常用工具\\ngo 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范。\\n\\n[火箭]\\n\\ngofmt，大部分的格式问题可以通过\\ngofmt解决，\\ngofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以\\ngofmt 的结果为准。\\n\\n[火]\\n\\ngoimports ，此工具在gofmt 的基础上增加了自动删除和引入包。\\n\\n[灯泡]\\n\\ngo vet ，vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。编译前先执行代码静态分析。\\n\\n[旗子]\\n\\ngolint ，类似javascript中的\\njslint的工具，主要功能就是检测代码中不规范的地方。\\n\",\n  \"timestamp\": \"2026-01-06T03:31:48.841Z\"\n}",
  "respondedAt": "2026-01-06T03:31:48.859Z",
  "comments": [
    {
      "type": "selection",
      "comment": "可以将 代码规范 放进去：\n\n Golang 代码规范\n1. 前言\n为形成公司统一的 Go 编码风格，以保障公司项目代码的易维护性和编码安全性，特制定本规范。\n每项规范内容，给出了要求等级，其定义为：\n\n[火箭]\n\n必须（Mandatory）：用户必须采用。\n\n[火]\n\n推荐（Preferable）：用户理应采用，但如有特殊情况，可以不采用。\n\n[灯泡]\n\n可选（Optional）：用户可参考，自行决定是否采用。\n2. 代码风格\n2.1 【必须】格式化\n● 代码都必须用gofmt格式化。\n2.2 【推荐】换行\n● 建议一行代码不要超过 120 列，超过的情况，使用合理的换行方法换行。\n2.3 【必须】括号和空格\n\n[火箭]\n\n遵循gofmt的逻辑。\n\n[火]\n\n运算符和操作数之间要留空格。\n\n[灯泡]\n\n作为输入参数或者数组下标时，运算符和运算数之间不需要空格，紧凑展示。\n2.4 【必须】import规范\n\n[火箭]\n\n使用goimports自动格式化引入的包名。\n\n[火]\n\n引入单个包，也使用括号包裹。\n// 应该采用如下格式：\nimport (\"fmt\")\n// 而不是这样：\nimport \"fmt\"\n\n[火箭]\n\n 如果你引入了多种类型的包，必须对包进行分组管理，将包分为标准库包、程序内部包、第三方包，并将标准库作为第一组，三组包用空行间隔。\n\n[火]\n\ngoimports或者\ngofmt会自动把依赖包按首字母排序。\n\n[灯泡]\n\n匿名包的引用必须使用一个新的分组引入。\n\n[旗子]\n\n不要使用相对路径引入包。\n\n// 不要采用这种方式\nimport (\n  \"../net\"\n)\n● 应该使用完整的路径引入包：\nimport (\n  \"xxxx.com/proj/net\"\n)\n● 包名和git 路径名不一致时，使用别名代替\nimport (\n  opentracing \"github.com/opentracing/opentracing-go\"\n)\n\n[火箭]\n\n【推荐】在匿名引入的每个包上推荐写上注释说明。\n\n[火]\n\n应该采用如下方式进行组织你的包。\nimport (\n  // standard package\n\"encoding/json\"\n\"strings\"\n\n// inner package\n\"myproject/models\"\n\"myproject/controller\"\n\n// third-party package\n\"git.obc.im/obc/utils\"\n\"git.obc.im/dep/beego\"\n\"git.obc.im/dep/mysql\"\n\n// alias package\nopentracing \"github.com/opentracing/opentracing-go\"\n\n// anonymous import package\n// import filesystem storage driver\n_ \"github.com/org/repo/pkg/storage/filesystem\n)\n\n2.5 【必须】错误处理\n2.5.1 【必须】error处理\n\n[火箭]\n\nerror作为函数的值返回，必须对error进行处理, 或将返回值赋值给明确忽略。\n\n[火]\n\nerror作为函数的值返回且有多个返回值的时候，error必须是最后一个参数。\n// 不要采用这种方式\nfunc do() (error, int) {\n}\n// 要采用下面的方式\nfunc do() (int, error) {\n}\n\n[火箭]\n\n错误描述不需要标点结尾。\n\n[火]\n\n采用独立的错误流进行处理。\n// 不要采用这种方式\nif err != nil {\n  // error handling\n} else {\n  // normal code\n}\n\n// 而要采用下面的方式\nif err != nil {\n  // error handling\n  return // or continue, etc.\n}\n// normal code\n\n- 如果返回值需要初始化，则采用下面的方式：\nx, err := f()\nif err != nil {\n  // error handling\n  return // or continue, etc.\n}\n// use x\n\n●  错误返回的判断独立处理，不与其他变量组合逻辑判断。\n// 不要采用这种方式：\nx, y, err := f()\nif err != nil || y == nil {\n  return err   // 当y与err都为空时，函数的调用者会出现错误的调用逻辑\n}\n\n// 应当使用如下方式：\nx, y, err := f()\nif err != nil {\n  return err\n}\nif y == nil {\n  return fmt.Errorf(\"some error\")\n}\n● 【推荐】建议 go1.13 以上，error 生成方式为：fmt.Errorf(\"module xxx: %w\", err)\n\n 2.5.2 【必须】panic 处理\nPANIC\n[火箭] 在业务逻辑处理中禁止使用panic。\n[火] 在main包中只有当完全不可运行的情况可使用panic，例如：文件无法打开，数据库无法连接导致程序无法正常运行。\n[灯泡] 对于其它的包，可导出的接口不能有panic，只能在包内使用。\n[旗子] 建议在main包中使用log.Fatal来记录错误，这样就可以由log来结束程序，或者将panic抛出的异常记录到日志文件中，方便排查问题。\n[火箭]panic捕获只能到goroutine最顶层，每个自行启动的goroutine，必须在入口处捕获panic，并打印详细堆栈信息或进行其它处理。\n2.5.3 【必须】recover处理\n\n[火箭]\n\nrecover 用于捕获runtime的异常，禁止滥用recover。\n\n[火]\n\n必须在defer中使用，一般用来捕获程序运行期间发生异常抛出的panic或程序主动抛出的\npanic。\npackage main\nimport (\n  \"log\"\n)\nfunc main() {\n  defer func() {\n      if err := recover(); err != nil {\n          // do something or record log\n      log.Println(\"exec panic error: \", err)\n          // log.Println(debug.Stack())\n      }\n  }()\n  \n  getOne()\n  \n  panic(11) //手动抛出panic\n}\n// getOne 模拟slice越界 runtime运行时抛出的panic\nfunc getOne() {\n  defer func() {\n      if err := recover(); err != nil {\n          // do something or record log\n      log.Println(\"exec panic error: \", err)\n          // log.Println(debug.Stack())\n      }\n  }()\n  \n  var arr = []string{\"a\", \"b\", \"c\"}\n  log.Println(\"hello,\", arr[4])\n}\n\n// 执行结果：\n// 2020/01/02 17:18:53 exec panic error:  runtime error: index out of range\n// 2020/01/02 17:18:53 exec panic error:  11\n\n2.6 【必须】单元测试\n\n[火箭]\n\n单元测试文件名命名规范为\nexample_test.go。\n\n[火]\n\n测试用例的函数名称必须以\nTest开头，例如\nTestExample。\n\n[灯泡]\n\n每个重要的可导出函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试。\n2.7 【必须】类型断言失败处理\n● type assertion的单个返回值形式针对不正确的类型将产生panic。因此，请始终使用“comma ok”的惯用法。\n// 不要采用这种方式\nt := i.(string)\n// 而要采用下面的方式\nt, ok := i.(string)\nif !ok {\n// 优雅地处理错误\n}\n3. 注释\n1. 在编码阶段同步写好变量、函数、包注释，注释可以通过godoc导出生成文档。\n2. 注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾。\n3. 程序中每一个被导出的(大写的)名字，都应该有一个文档注释。\n\n3.1 【必须】包注释\n\n[火箭]\n\n每个包都应该有一个包注释。\n\n[火]\n\n包如果有多个 go 文件，只需要出现在一个 go 文件中（一般是和包同名的文件）即可，格式为：\n“// Package 包名 包信息描述”。\n// Package math provides basic constants and mathematical functions.\npackage math\n// 或者\n/*\nPackage template implements data-driven templates for generating textual\noutput such as HTML.\n....\n*/\npackage template\n\n 3.2 【必须】结构体注释\n\n[火箭]\n\n每个需要导出的自定义结构体或者接口都必须有注释说明。\n\n[火]\n\n注释对结构进行简要介绍，放在结构体定义的前一行。\n\n[灯泡]\n\n格式为：\n\"// 结构体名 结构体信息描述\"。\n\n[旗子]\n\n结构体内的每个需要导出的成员变量都要有说明，该说明放在成员变量的前一行。\n\n// User 用户结构定义了用户基础信息\ntype User struct {\n  // UserName 用户名\n  UserName string\n  // Email 邮箱\n  Email string\n}\n 3.3 【必须】方法注释\n\n[火箭]\n\n每个需要导出的函数或者方法（结构体或者接口下的函数称为方法）都必须有注释。\n\n[火]\n\n注释描述函数或方法功能、调用方等信息。\n\n[灯泡]\n\n格式为：\n\"// 函数名 函数信息描述\"。\n// NewtAttrModel 是属性数据层操作类的工厂方法\nfunc NewAttrModel(ctx common.Context)AttrModel {\n  // TODO\n}\n3.4 【必须】变量注释\n\n[火箭]\n\n每个需要导出的常量和变量都必须有注释说明。\n\n[火]\n\n该注释对常量或变量进行简要介绍，放在常量或者变量定义的前一行。\n\n[灯泡]\n\n格式为：\n\"// 变量名 变量信息描述\"。\n// FlagConfigFile 配置文件的命令行参数名\nconst FlagConfigFile = \"--config\"\n// FullName 返回指定用户名的完整名称\nvar FullName = func(username string) string {\n  return fmt.Sprintf(\"fake-%s\", username)\n}\n 3.5 【必须】类型注释\n\n[火箭]\n\n每个需要导出的类型定义(type definition)和类型别名(type aliases)都必须有注释说明。\n\n[火]\n\n该注释对类型进行简要介绍，放在定义的前一行。\n\n[灯泡]\n\n格式为：\n\"// 类型名 类型信息描述\"。\n// StorageClass 存储类型\ntype StorageClass string\n// FakeTime 标准库时间的类型别名\ntype FakeTime = time.Time\n4. 命名规范\n命名是代码规范中很重要的一部分，统一的命名规范有利于提高代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。\n\n4.1 【推荐】包命名\n包命名\n[火箭] 保持package  的名字和目录一致。\n[火] 尽量采取有意义、简短的包名，尽量不要和标准库冲突。\n[灯泡] 包名应该为小写单词，不要使用下划线或者混合大小写，使用多级目录来划分层级。\n[旗子] 项目名可以通过中划线来连接多个单词。\n[火箭] 简单明了的包命名，如：time、list、http。\n[火] 不要使用无意义的包名，如：util、common、misc。\n\n 4.2 【必须】文件命名\n\n[火箭]\n\n采用有意义，简短的文件名。\n\n[火]\n\n文件名应该采用小写，并且使用下划线分割各个单词。\n\n4.3 【必须】结构体命名\n\n[火箭]\n\n采用驼峰命名方式，首字母根据访问控制采用大写或者小写。\n\n[火]\n\n结构体名应该是名词或名词短语，如\nCustomer、\nWikiPage、\nAccount、\nAddressParser。\n\n[灯泡]\n\n避免使用\nManager、\nProcessor、\nData、\nInfo\n 这样的结构体名，结构体名不应当是动词。\n\n[旗子]\n\n结构体的申明和初始化格式采用多行，例如：\n// User 多行申明\ntype User struct{\n  // Username 用户名\n  UserName string\n  // Email 电子邮件地址\n  Email string\n  }\n  // 多行初始化\n  u := User{\n  UserName: \"john\",\n  Email:    \"john@example.com\",\n}\n4.4 【推荐】接口命名\n\n[火箭]\n\n命名规则基本保持和结构体命名规则一致。\n\n[火]\n\n单个函数的结构名以 \"er\" 作为后缀，例如\nReader，Writer。\n// Reader 字节数组读取接口\ntype Reader interface {\n  // Read 读取整个给定的字节数据并返回读取的长度\n  Read(p []byte) (n int, err error)\n}\n\n[火箭]\n\n两个函数的接口名综合两个函数名。\n\n[火]\n\n三个以上函数的接口名，类似于结构体名。\n// Car 小汽车结构申明\ntype Car interface {\n  // Start ...\n  Start([]byte)\n  // Stop ...\n  Stop() error\n  // Recover ...\n  Recover()\n}\n\n4.5 【必须】变量命名\n\n[火箭]\n\n变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写。\n\n[火]\n\n特有名词时，需要遵循以下规则：\n    - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient；\n    - 其他情况都应该使用该名词原有的写法，如 `APIClient`、repoID、UserID；\n    - 错误示例：UrlArray，应该写成urlArray或者URLArray；\n\n\n[火箭]\n\n若变量类型为bool类型，则名称应以Has，Is，Can或者Allow开头。\n\n[火]\n\n私有全局变量和局部变量规范一致，均以小写字母开头。\n\n4.6 【必须】常量命名\n● 常量均需遵循驼峰式。\n// AppVersion 应用程序版本号定义\nconst AppVersion = \"1.0.0\"\n\n●  如果是枚举类型的常量，需要先创建相应类型：\n// Scheme 传输协议\ntype Scheme string\nconst (\n// HTTP 表示HTTP明文传输协议\nHTTP Scheme = \"http\"\n// HTTPS 表示HTTPS加密传输协议\n)\n\n● 私有全局常量和局部变量规范一致，均以小写字母开头。\nconst appVersion = \"1.0.0\"\n5. 控制结构\n 5.1  【推荐】if\n● if 接受初始化语句，约定如下方式建立局部变量：\nif err := file.Chmod(0664); err != nil {\n  return err\n}\n 5.2    【推荐】for\n●  采用短声明建立局部变量：\nsum := 0\nfor i := 0; i < 10; i++ {\n  sum += 1\n}\n 5.3    【必须】range\n●  如果只需要第一项（key），就丢弃第二个：\n\nfor key := range m {\nif key.expired() {\n    delete(m, key)\n  }\n}\n● 如果只需要第二项，则把第一项置为下划线：\nsum := 0\nfor _, value := range array {\n  sum += value\n}\n5.4    【必须】switch\n● 要求必须有default：\nswitch os := runtime.GOOS; os {\ncase \"darwin\":\n    fmt.Println(\"OS X.\")\ncase \"linux\":\n    fmt.Println(\"Linux.\")\ndefault:\n    // freebsd, openbsd,\n    // plan9, windows...\n    fmt.Printf(\"%s.\\n\", os)\n  }\n5.5 【推荐】return\n●  尽早return，一旦有错误发生，马上返回：\nf, err := os.Open(name)\nif err != nil {\n  return err\n}\nd, err := f.Stat()\nif err != nil {\n  f.Close()\n  return err\n}\ncodeUsing(f, d)\n5.6 【必须】goto\n● 业务代码禁止使用goto，其他框架或底层源码推荐尽量不用\n\n6. 函数\n6.1 【推荐】函数参数\n● 函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其它情况不建议使用命名返回。\n// Parent1 ...\nfunc (n Node) Parent1()Node\n// Parent2 ...\nfunc (n Node) Parent2() (Node, error)\n// Location ...\nfunc (f *Foo) Location() (lat, long float64, err error)\n\n[火箭]\n\n传入变量和返回变量以小写字母开头。\n\n[火]\n\n参数数量均不能超过 5 个。\n\n[灯泡]\n\n尽量用值传递，非指针传递。\n\n[旗子]\n\n传入参数是map，slice，\nchan，\ninterface不要传递指针。\n\n 6.2 【必须】defer\n\n[火箭]\n\n当存在资源管理时，应紧跟defer函数进行资源的释放。\n\n[火]\n\n判断是否有错误发生之后，再defer释放资源。\nresp, err := http.Get(url)\nif err != nil {\n  return err\n}\n// 如果操作成功，再defer Close()\ndefer resp.Body.Close()\n● 禁止在循环中使用defer，举例如下：\n// 不要这样使用\nfunc filterSomething(values []string) {\nfor _, v := range values {\n    fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\n    if err != nil {\n        // xxx\n    }\n    defer fields.Close()\n    // 继续使用fields\n  }\n}\n// 应当使用如下的方式：\nfunc filterSomething(values []string) {\n  for _, v := range values {\n    func() {\n        fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\n        if err != nil {\n        ...\n        }\n        defer fields.Close()\n        // 继续使用fields\n    }()\n  }\n}\n 6.3 【必须】方法的接收器\n\n[火箭]\n\n接收器的命名在函数超过 20 行的时候不要用单字符。\n\n[火]\n\n命名不能采用me，this，self这类易混淆名称。\n\n6.4 【推荐】代码行数\n\n[火箭]\n\n【必须】文件长度不能超过 800 行。\n\n[火]\n\n【推荐】函数长度不能超过 80 行。\n 6.5 【必须】嵌套\n● 嵌套深度不能超过 4 层：\n// AddArea 添加成功或出错\nfunc (s *BookingService) AddArea(areas ...string) error {\n  s.Lock()\n  defer s.Unlock()\n  \n  for _, area := range areas {\n      for _, has := range s.areas {\n          if area == has {\n              return srverr.ErrAreaConflict\n          }\n      }\n      s.areas = append(s.areas, area)\n      s.areaOrders[area] = new(order.AreaOrder)\n    }\n  return nil\n}\n\n// 建议调整为这样：\n// AddArea 添加成功或出错\nfunc (s *BookingService) AddArea(areas ...string) error {\n  s.Lock()\n  defer s.Unlock()\n  \n  for _, area := range areas {\n      if s.HasArea(area) {\n          return srverr.ErrAreaConflict\n      }\n      s.areas = append(s.areas, area)\n      s.areaOrders[area] = new(order.AreaOrder)\n  }\n  return nil\n}\n\n// HasArea ...\nfunc (s *BookingService) HasArea(area string) bool {\n  for _, has := range s.areas {\n      if area == has {\n          return true\n      }\n    }\n    return false\n}\n6.6 【推荐】变量声明\n● 变量声明尽量放在变量第一次使用前面，就近原则。\n\n6.7 【必须】魔法数字\n● 如果魔法数字出现超过 2 次，则禁止使用。\nfunc getArea(r float64) float64 {\n  return 3.14 * r * r\n}\n\nfunc getLength(r float64) float64 {\n  return 3.14 * 2 * r\n}\n\n// PI ...\nconst PI = 3.14\nfunc getArea(r float64) float64 {\n  return PI * r * r\n}\n\nfunc getLength(r float64) float64 {\n  return PI * 2 * r\n}\n7. 依赖管理\n 7.1 【必须】go1.11以上必须使用 go modules模式：\ngo mod init github.com/group/myrepo\n7.2 【推荐】代码提交\n\n[火箭]\n\n建议所有不对外开源的工程的\nmodule name使用\ngithub.com/group/repo，方便他人直接引用\n\n[火]\n\n建议使用go modules作为依赖管理的项目不提交vendor目录\n\n[灯泡]\n\n建议使用go modules管理依赖的项目将go.sum文件不添加到忽略提交规则中\n8. 应用服务\n8.1 【推荐】应用服务接口建议有readme.md\n● 其中建议包括服务基本描述、使用方法、部署时的限制与要求、基础环境依赖（例如最低 go 版本、最低外部通用包版本）等。\n8.2 【必须】应用服务必须要有接口测试。\n附：常用工具\ngo 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范。\n\n[火箭]\n\ngofmt，大部分的格式问题可以通过\ngofmt解决，\ngofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以\ngofmt 的结果为准。\n\n[火]\n\ngoimports ，此工具在gofmt 的基础上增加了自动删除和引入包。\n\n[灯泡]\n\ngo vet ，vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。编译前先执行代码静态分析。\n\n[旗子]\n\ngolint ，类似javascript中的\njslint的工具，主要功能就是检测代码中不规范的地方。",
      "timestamp": "2026-01-06T03:31:45.183Z",
      "selectedText": "# Technology Stack",
      "highlightColor": {
        "bg": "rgba(255, 235, 59, 0.3)",
        "border": "#FFEB3B",
        "name": "#ffeb3b"
      },
      "id": "comment_1767670305183_wekn04m05",
      "startOffset": 0,
      "endOffset": 18
    }
  ]
}