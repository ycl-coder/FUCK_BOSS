{
  "id": "snapshot_1767671487915_r0l800uhw",
  "approvalId": "approval_1767671463859_f1qhcjd4p",
  "approvalTitle": "技术栈文档 (tech.md) - 已添加Go代码规范",
  "version": 3,
  "timestamp": "2026-01-06T03:51:27.915Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Technology Stack\n\n## Project Type\n\n全国公司曝光平台是一个基于 gRPC 的 Web 应用，采用前后端分离架构。后端使用 Go 语言提供 gRPC 服务，前端使用 React 构建用户界面。\n\n## Core Technologies\n\n### Primary Language(s)\n\n- **后端语言**: Go 1.21+\n- **前端语言**: TypeScript 5.0+ (React)\n- **协议定义**: Protocol Buffers (protobuf)\n- **包管理**: \n  - Go: `go mod`\n  - Frontend: `npm` / `yarn` / `pnpm`\n\n### Key Dependencies/Libraries\n\n#### 后端 (Go)\n- **gRPC-Go**: `google.golang.org/grpc` - gRPC 框架核心\n- **Protocol Buffers**: `google.golang.org/protobuf` - 数据序列化\n- **PostgreSQL 驱动**: `github.com/lib/pq` 或 `gorm.io/gorm` - 数据库访问\n- **Redis 客户端**: `github.com/redis/go-redis/v9` - 缓存和会话管理\n- **依赖注入**: `github.com/google/wire` 或 `github.com/uber-go/fx` - DDD 依赖管理\n- **配置管理**: `github.com/spf13/viper` - 配置读取\n- **日志**: `go.uber.org/zap` - 结构化日志\n- **验证**: `github.com/go-playground/validator/v10` - 数据验证\n- **HTTP 网关**: `github.com/grpc-ecosystem/grpc-gateway/v2` - gRPC 转 HTTP/REST（可选）\n\n#### 前端 (React)\n- **React**: `^18.2.0` - UI 框架\n- **TypeScript**: `^5.0.0` - 类型安全\n- **路由**: `react-router-dom` - 前端路由\n- **状态管理**: `zustand` 或 `@reduxjs/toolkit` - 状态管理\n- **HTTP 客户端**: `axios` 或 `@tanstack/react-query` - API 调用\n- **gRPC Web**: `@grpc/grpc-js` + `@grpc-web/protoc-gen-grpc-web` - gRPC Web 客户端\n- **UI 组件库**: `antd` 或 `@mui/material` - 组件库\n- **构建工具**: `vite` 或 `create-react-app` - 构建和开发工具\n\n### Application Architecture\n\n#### 架构模式：领域驱动设计 (DDD)\n\n采用 DDD 分层架构，将业务逻辑与基础设施分离：\n\n```\n┌─────────────────────────────────────┐\n│   Presentation Layer (API/UI)       │\n│   - gRPC Handlers                   │\n│   - HTTP Gateway (可选)             │\n└──────────────┬──────────────────────┘\n               │\n┌──────────────▼──────────────────────┐\n│   Application Layer                  │\n│   - Use Cases / Application Services │\n│   - DTOs / Commands / Queries       │\n└──────────────┬──────────────────────┘\n               │\n┌──────────────▼──────────────────────┐\n│   Domain Layer (核心业务逻辑)        │\n│   - Entities (聚合根)               │\n│   - Value Objects                   │\n│   - Domain Services                 │\n│   - Repository Interfaces            │\n│   - Domain Events                   │\n└──────────────┬──────────────────────┘\n               │\n┌──────────────▼──────────────────────┐\n│   Infrastructure Layer               │\n│   - Repository Implementations       │\n│   - Database (PostgreSQL)           │\n│   - Cache (Redis)                   │\n│   - External Services                │\n└─────────────────────────────────────┘\n```\n\n#### 领域划分（Bounded Contexts）\n\n1. **内容领域 (Content Context)**\n   - 聚合根：`Post` (曝光内容)\n   - 值对象：`City`, `CompanyName`, `Content`\n   - 领域服务：内容发布、内容审核\n\n2. **搜索领域 (Search Context)**\n   - 聚合根：`SearchIndex`\n   - 领域服务：全文搜索、城市筛选\n\n3. **用户领域 (User Context)** (未来版本)\n   - 聚合根：`AnonymousUser`\n   - 领域服务：匿名标识管理\n\n### Data Storage\n\n#### Primary Storage: PostgreSQL\n\n- **版本**: PostgreSQL 14+\n- **用途**: \n  - 持久化存储曝光内容\n  - 存储城市、公司等基础数据\n  - 支持全文搜索（PostgreSQL Full-Text Search）\n- **连接池**: 使用 `pgx` 或 `gorm` 管理连接池\n- **迁移工具**: `golang-migrate/migrate` 或 `gorm` 自动迁移\n\n#### Caching: Redis\n\n- **版本**: Redis 7.0+\n- **用途**:\n  - 缓存热门内容列表\n  - 缓存城市列表、公司列表\n  - 搜索结果的短期缓存\n  - 限流和防刷机制\n  - 会话存储（未来版本）\n- **数据结构**:\n  - `String`: 简单缓存\n  - `Hash`: 对象缓存\n  - `Sorted Set`: 热门内容排行\n  - `Set`: 去重、标签\n\n#### Data Formats\n\n- **API 通信**: Protocol Buffers (protobuf)\n- **配置**: YAML / JSON\n- **日志**: JSON (结构化日志)\n\n### External Integrations\n\n#### APIs\n- **内容审核服务** (未来版本): 第三方内容审核 API\n- **地理位置服务** (可选): IP 定位服务\n\n#### Protocols\n- **gRPC**: 后端服务间通信\n- **gRPC-Web**: 前端与后端通信\n- **HTTP/REST**: 可选，通过 grpc-gateway 提供 RESTful API\n\n#### Authentication\n- **匿名发布**: 无需认证（第一版本）\n- **未来版本**: JWT Token 或 Session 认证\n\n## Development Environment\n\n### Build & Development Tools\n\n#### 后端\n- **Build System**: `go build` / `make`\n- **开发工具**: \n  - `air` - 热重载\n  - `golangci-lint` - 代码检查\n- **API 生成**: `protoc` + `protoc-gen-go` + `protoc-gen-go-grpc`\n- **代码生成**: `wire` (依赖注入代码生成)\n\n#### 前端\n- **Build System**: `vite` 或 `webpack`\n- **开发工具**: \n  - `vite` HMR (热模块替换)\n  - `eslint` - 代码检查\n  - `prettier` - 代码格式化\n\n### Code Quality Tools\n\n#### 后端\n- **Static Analysis**: `golangci-lint` (集成多种 linter)\n- **Formatting**: `gofmt` / `goimports`\n- **Testing Framework**: \n  - `testing` (标准库) - 单元测试\n  - `testify` - 测试断言和 mock\n  - `gomock` - 接口 mock 生成\n- **Coverage**: `go test -cover`\n- **Documentation**: `godoc` / `swagger` (如果提供 REST API)\n\n## Go 代码规范\n\n为形成统一的 Go 编码风格，以保障项目代码的易维护性和编码安全性，特制定本规范。\n\n每项规范内容，给出了要求等级，其定义为：\n\n- **[火箭] 必须（Mandatory）**：用户必须采用\n- **[火] 推荐（Preferable）**：用户理应采用，但如有特殊情况，可以不采用\n- **[灯泡] 可选（Optional）**：用户可参考，自行决定是否采用\n- **[旗子] 建议（Suggestion）**：最佳实践建议\n\n### 代码风格\n\n#### 2.1 【必须】格式化\n\n- **[火箭]** 代码都必须用 `gofmt` 格式化\n\n#### 2.2 【推荐】换行\n\n- **[火]** 建议一行代码不要超过 120 列，超过的情况，使用合理的换行方法换行\n\n#### 2.3 【必须】括号和空格\n\n- **[火箭]** 遵循 `gofmt` 的逻辑\n- **[火]** 运算符和操作数之间要留空格\n- **[灯泡]** 作为输入参数或者数组下标时，运算符和运算数之间不需要空格，紧凑展示\n\n#### 2.4 【必须】import 规范\n\n- **[火箭]** 使用 `goimports` 自动格式化引入的包名\n- **[火]** 引入单个包，也使用括号包裹\n  ```go\n  // 应该采用如下格式：\n  import (\"fmt\")\n  // 而不是这样：\n  import \"fmt\"\n  ```\n- **[火箭]** 如果你引入了多种类型的包，必须对包进行分组管理，将包分为标准库包、程序内部包、第三方包，并将标准库作为第一组，三组包用空行间隔\n- **[火]** `goimports` 或者 `gofmt` 会自动把依赖包按首字母排序\n- **[灯泡]** 匿名包的引用必须使用一个新的分组引入\n- **[旗子]** 不要使用相对路径引入包\n  ```go\n  // 不要采用这种方式\n  import (\n    \"../net\"\n  )\n  // 应该使用完整的路径引入包：\n  import (\n    \"xxxx.com/proj/net\"\n  )\n  ```\n- **[火箭]** 包名和 git 路径名不一致时，使用别名代替\n  ```go\n  import (\n    opentracing \"github.com/opentracing/opentracing-go\"\n  )\n  ```\n- **[火箭]** 【推荐】在匿名引入的每个包上推荐写上注释说明\n- **[火]** 应该采用如下方式进行组织你的包：\n  ```go\n  import (\n    // standard package\n    \"encoding/json\"\n    \"strings\"\n  \n    // inner package\n    \"myproject/models\"\n    \"myproject/controller\"\n  \n    // third-party package\n    \"git.obc.im/obc/utils\"\n    \"git.obc.im/dep/beego\"\n    \"git.obc.im/dep/mysql\"\n  \n    // alias package\n    opentracing \"github.com/opentracing/opentracing-go\"\n  \n    // anonymous import package\n    // import filesystem storage driver\n    _ \"github.com/org/repo/pkg/storage/filesystem\"\n  )\n  ```\n\n#### 2.5 【必须】错误处理\n\n##### 2.5.1 【必须】error 处理\n\n- **[火箭]** error 作为函数的值返回，必须对 error 进行处理，或将返回值赋值给明确忽略\n- **[火]** error 作为函数的值返回且有多个返回值的时候，error 必须是最后一个参数\n  ```go\n  // 不要采用这种方式\n  func do() (error, int) {\n  }\n  // 要采用下面的方式\n  func do() (int, error) {\n  }\n  ```\n- **[火箭]** 错误描述不需要标点结尾\n- **[火]** 采用独立的错误流进行处理\n  ```go\n  // 不要采用这种方式\n  if err != nil {\n    // error handling\n  } else {\n    // normal code\n  }\n  \n  // 而要采用下面的方式\n  if err != nil {\n    // error handling\n    return // or continue, etc.\n  }\n  // normal code\n  ```\n- 如果返回值需要初始化，则采用下面的方式：\n  ```go\n  x, err := f()\n  if err != nil {\n    // error handling\n    return // or continue, etc.\n  }\n  // use x\n  ```\n- 错误返回的判断独立处理，不与其他变量组合逻辑判断\n  ```go\n  // 不要采用这种方式：\n  x, y, err := f()\n  if err != nil || y == nil {\n    return err   // 当y与err都为空时，函数的调用者会出现错误的调用逻辑\n  }\n  \n  // 应当使用如下方式：\n  x, y, err := f()\n  if err != nil {\n    return err\n  }\n  if y == nil {\n    return fmt.Errorf(\"some error\")\n  }\n  ```\n- **[火]** 【推荐】建议 go1.13 以上，error 生成方式为：`fmt.Errorf(\"module xxx: %w\", err)`\n\n##### 2.5.2 【必须】panic 处理\n\n- **[火箭]** 在业务逻辑处理中禁止使用 panic\n- **[火]** 在 main 包中只有当完全不可运行的情况可使用 panic，例如：文件无法打开，数据库无法连接导致程序无法正常运行\n- **[灯泡]** 对于其它的包，可导出的接口不能有 panic，只能在包内使用\n- **[旗子]** 建议在 main 包中使用 `log.Fatal` 来记录错误，这样就可以由 log 来结束程序，或者将 panic 抛出的异常记录到日志文件中，方便排查问题\n- **[火箭]** panic 捕获只能到 goroutine 最顶层，每个自行启动的 goroutine，必须在入口处捕获 panic，并打印详细堆栈信息或进行其它处理\n\n##### 2.5.3 【必须】recover 处理\n\n- **[火箭]** recover 用于捕获 runtime 的异常，禁止滥用 recover\n- **[火]** 必须在 defer 中使用，一般用来捕获程序运行期间发生异常抛出的 panic 或程序主动抛出的 panic\n  ```go\n  package main\n  import (\n    \"log\"\n  )\n  func main() {\n    defer func() {\n        if err := recover(); err != nil {\n            // do something or record log\n            log.Println(\"exec panic error: \", err)\n            // log.Println(debug.Stack())\n        }\n    }()\n    \n    getOne()\n    \n    panic(11) //手动抛出panic\n  }\n  // getOne 模拟slice越界 runtime运行时抛出的panic\n  func getOne() {\n    defer func() {\n        if err := recover(); err != nil {\n            // do something or record log\n            log.Println(\"exec panic error: \", err)\n            // log.Println(debug.Stack())\n        }\n    }()\n    \n    var arr = []string{\"a\", \"b\", \"c\"}\n    log.Println(\"hello,\", arr[4])\n  }\n  ```\n\n#### 2.6 【必须】单元测试\n\n- **[火箭]** 单元测试文件名命名规范为 `example_test.go`\n- **[火]** 测试用例的函数名称必须以 `Test` 开头，例如 `TestExample`\n- **[灯泡]** 每个重要的可导出函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试\n\n#### 2.7 【必须】类型断言失败处理\n\n- type assertion 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用\"comma ok\"的惯用法\n  ```go\n  // 不要采用这种方式\n  t := i.(string)\n  // 而要采用下面的方式\n  t, ok := i.(string)\n  if !ok {\n    // 优雅地处理错误\n  }\n  ```\n\n### 注释\n\n1. 在编码阶段同步写好变量、函数、包注释，注释可以通过 `godoc` 导出生成文档\n2. 注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾\n3. 程序中每一个被导出的(大写的)名字，都应该有一个文档注释\n\n#### 3.1 【必须】包注释\n\n- **[火箭]** 每个包都应该有一个包注释\n- **[火]** 包如果有多个 go 文件，只需要出现在一个 go 文件中（一般是和包同名的文件）即可，格式为：\"// Package 包名 包信息描述\"\n  ```go\n  // Package math provides basic constants and mathematical functions.\n  package math\n  // 或者\n  /*\n  Package template implements data-driven templates for generating textual\n  output such as HTML.\n  ....\n  */\n  package template\n  ```\n\n#### 3.2 【必须】结构体注释\n\n- **[火箭]** 每个需要导出的自定义结构体或者接口都必须有注释说明\n- **[火]** 注释对结构进行简要介绍，放在结构体定义的前一行\n- **[灯泡]** 格式为：\"// 结构体名 结构体信息描述\"\n- **[旗子]** 结构体内的每个需要导出的成员变量都要有说明，该说明放在成员变量的前一行\n  ```go\n  // User 用户结构定义了用户基础信息\n  type User struct {\n    // UserName 用户名\n    UserName string\n    // Email 邮箱\n    Email string\n  }\n  ```\n\n#### 3.3 【必须】方法注释\n\n- **[火箭]** 每个需要导出的函数或者方法（结构体或者接口下的函数称为方法）都必须有注释\n- **[火]** 注释描述函数或方法功能、调用方等信息\n- **[灯泡]** 格式为：\"// 函数名 函数信息描述\"\n  ```go\n  // NewAttrModel 是属性数据层操作类的工厂方法\n  func NewAttrModel(ctx common.Context) AttrModel {\n    // TODO\n  }\n  ```\n\n#### 3.4 【必须】变量注释\n\n- **[火箭]** 每个需要导出的常量和变量都必须有注释说明\n- **[火]** 该注释对常量或变量进行简要介绍，放在常量或者变量定义的前一行\n- **[灯泡]** 格式为：\"// 变量名 变量信息描述\"\n  ```go\n  // FlagConfigFile 配置文件的命令行参数名\n  const FlagConfigFile = \"--config\"\n  // FullName 返回指定用户名的完整名称\n  var FullName = func(username string) string {\n    return fmt.Sprintf(\"fake-%s\", username)\n  }\n  ```\n\n#### 3.5 【必须】类型注释\n\n- **[火箭]** 每个需要导出的类型定义(type definition)和类型别名(type aliases)都必须有注释说明\n- **[火]** 该注释对类型进行简要介绍，放在定义的前一行\n- **[灯泡]** 格式为：\"// 类型名 类型信息描述\"\n  ```go\n  // StorageClass 存储类型\n  type StorageClass string\n  // FakeTime 标准库时间的类型别名\n  type FakeTime = time.Time\n  ```\n\n### 命名规范\n\n命名是代码规范中很重要的一部分，统一的命名规范有利于提高代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。\n\n#### 4.1 【推荐】包命名\n\n- **[火箭]** 保持 package 的名字和目录一致\n- **[火]** 尽量采取有意义、简短的包名，尽量不要和标准库冲突\n- **[灯泡]** 包名应该为小写单词，不要使用下划线或者混合大小写，使用多级目录来划分层级\n- **[旗子]** 项目名可以通过中划线来连接多个单词\n- **[火箭]** 简单明了的包命名，如：time、list、http\n- **[火]** 不要使用无意义的包名，如：util、common、misc\n\n#### 4.2 【必须】文件命名\n\n- **[火箭]** 采用有意义，简短的文件名\n- **[火]** 文件名应该采用小写，并且使用下划线分割各个单词\n\n#### 4.3 【必须】结构体命名\n\n- **[火箭]** 采用驼峰命名方式，首字母根据访问控制采用大写或者小写\n- **[火]** 结构体名应该是名词或名词短语，如 `Customer`、`WikiPage`、`Account`、`AddressParser`\n- **[灯泡]** 避免使用 `Manager`、`Processor`、`Data`、`Info` 这样的结构体名，结构体名不应当是动词\n- **[旗子]** 结构体的申明和初始化格式采用多行，例如：\n  ```go\n  // User 多行申明\n  type User struct {\n    // Username 用户名\n    UserName string\n    // Email 电子邮件地址\n    Email string\n  }\n  // 多行初始化\n  u := User{\n    UserName: \"john\",\n    Email:    \"john@example.com\",\n  }\n  ```\n\n#### 4.4 【推荐】接口命名\n\n- **[火箭]** 命名规则基本保持和结构体命名规则一致\n- **[火]** 单个函数的结构名以 \"er\" 作为后缀，例如 `Reader`，`Writer`\n  ```go\n  // Reader 字节数组读取接口\n  type Reader interface {\n    // Read 读取整个给定的字节数据并返回读取的长度\n    Read(p []byte) (n int, err error)\n  }\n  ```\n- **[火箭]** 两个函数的接口名综合两个函数名\n- **[火]** 三个以上函数的接口名，类似于结构体名\n  ```go\n  // Car 小汽车结构申明\n  type Car interface {\n    // Start ...\n    Start([]byte)\n    // Stop ...\n    Stop() error\n    // Recover ...\n    Recover()\n  }\n  ```\n\n#### 4.5 【必须】变量命名\n\n- **[火箭]** 变量名必须遵循驼峰式，首字母根据访问控制决定使用大写或小写\n- **[火]** 特有名词时，需要遵循以下规则：\n  - 如果变量为私有，且特有名词为首个单词，则使用小写，如 `apiClient`\n  - 其他情况都应该使用该名词原有的写法，如 `APIClient`、`repoID`、`UserID`\n  - 错误示例：`UrlArray`，应该写成 `urlArray` 或者 `URLArray`\n- **[火箭]** 若变量类型为 bool 类型，则名称应以 `Has`，`Is`，`Can` 或者 `Allow` 开头\n- **[火]** 私有全局变量和局部变量规范一致，均以小写字母开头\n\n#### 4.6 【必须】常量命名\n\n- 常量均需遵循驼峰式\n  ```go\n  // AppVersion 应用程序版本号定义\n  const AppVersion = \"1.0.0\"\n  ```\n- 如果是枚举类型的常量，需要先创建相应类型：\n  ```go\n  // Scheme 传输协议\n  type Scheme string\n  const (\n    // HTTP 表示HTTP明文传输协议\n    HTTP Scheme = \"http\"\n    // HTTPS 表示HTTPS加密传输协议\n    HTTPS Scheme = \"https\"\n  )\n  ```\n- 私有全局常量和局部变量规范一致，均以小写字母开头\n  ```go\n  const appVersion = \"1.0.0\"\n  ```\n\n### 控制结构\n\n#### 5.1 【推荐】if\n\n- if 接受初始化语句，约定如下方式建立局部变量：\n  ```go\n  if err := file.Chmod(0664); err != nil {\n    return err\n  }\n  ```\n\n#### 5.2 【推荐】for\n\n- 采用短声明建立局部变量：\n  ```go\n  sum := 0\n  for i := 0; i < 10; i++ {\n    sum += 1\n  }\n  ```\n\n#### 5.3 【必须】range\n\n- 如果只需要第一项（key），就丢弃第二个：\n  ```go\n  for key := range m {\n    if key.expired() {\n      delete(m, key)\n    }\n  }\n  ```\n- 如果只需要第二项，则把第一项置为下划线：\n  ```go\n  sum := 0\n  for _, value := range array {\n    sum += value\n  }\n  ```\n\n#### 5.4 【必须】switch\n\n- 要求必须有 default：\n  ```go\n  switch os := runtime.GOOS; os {\n  case \"darwin\":\n    fmt.Println(\"OS X.\")\n  case \"linux\":\n    fmt.Println(\"Linux.\")\n  default:\n    // freebsd, openbsd,\n    // plan9, windows...\n    fmt.Printf(\"%s.\\n\", os)\n  }\n  ```\n\n#### 5.5 【推荐】return\n\n- 尽早 return，一旦有错误发生，马上返回：\n  ```go\n  f, err := os.Open(name)\n  if err != nil {\n    return err\n  }\n  d, err := f.Stat()\n  if err != nil {\n    f.Close()\n    return err\n  }\n  codeUsing(f, d)\n  ```\n\n#### 5.6 【必须】goto\n\n- 业务代码禁止使用 goto，其他框架或底层源码推荐尽量不用\n\n### 函数\n\n#### 6.1 【推荐】函数参数\n\n- 函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，其它情况不建议使用命名返回\n  ```go\n  // Parent1 ...\n  func (n Node) Parent1() Node\n  // Parent2 ...\n  func (n Node) Parent2() (Node, error)\n  // Location ...\n  func (f *Foo) Location() (lat, long float64, err error)\n  ```\n- **[火箭]** 传入变量和返回变量以小写字母开头\n- **[火]** 参数数量均不能超过 5 个\n- **[灯泡]** 尽量用值传递，非指针传递\n- **[旗子]** 传入参数是 map，slice，chan，interface 不要传递指针\n\n#### 6.2 【必须】defer\n\n- **[火箭]** 当存在资源管理时，应紧跟 defer 函数进行资源的释放\n- **[火]** 判断是否有错误发生之后，再 defer 释放资源\n  ```go\n  resp, err := http.Get(url)\n  if err != nil {\n    return err\n  }\n  // 如果操作成功，再defer Close()\n  defer resp.Body.Close()\n  ```\n- 禁止在循环中使用 defer，举例如下：\n  ```go\n  // 不要这样使用\n  func filterSomething(values []string) {\n    for _, v := range values {\n      fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\n      if err != nil {\n        // xxx\n      }\n      defer fields.Close()\n      // 继续使用fields\n    }\n  }\n  // 应当使用如下的方式：\n  func filterSomething(values []string) {\n    for _, v := range values {\n      func() {\n        fields, err := db.Query(v) // 示例，实际不要这么查询，防止sql注入\n        if err != nil {\n          // ...\n        }\n        defer fields.Close()\n        // 继续使用fields\n      }()\n    }\n  }\n  ```\n\n#### 6.3 【必须】方法的接收器\n\n- **[火箭]** 接收器的命名在函数超过 20 行的时候不要用单字符\n- **[火]** 命名不能采用 me，this，self 这类易混淆名称\n\n#### 6.4 【推荐】代码行数\n\n- **[火箭]** 【必须】文件长度不能超过 800 行\n- **[火]** 【推荐】函数长度不能超过 80 行\n\n#### 6.5 【必须】嵌套\n\n- 嵌套深度不能超过 4 层：\n  ```go\n  // AddArea 添加成功或出错\n  func (s *BookingService) AddArea(areas ...string) error {\n    s.Lock()\n    defer s.Unlock()\n    \n    for _, area := range areas {\n      for _, has := range s.areas {\n        if area == has {\n          return srverr.ErrAreaConflict\n        }\n      }\n      s.areas = append(s.areas, area)\n      s.areaOrders[area] = new(order.AreaOrder)\n    }\n    return nil\n  }\n  \n  // 建议调整为这样：\n  // AddArea 添加成功或出错\n  func (s *BookingService) AddArea(areas ...string) error {\n    s.Lock()\n    defer s.Unlock()\n    \n    for _, area := range areas {\n      if s.HasArea(area) {\n        return srverr.ErrAreaConflict\n      }\n      s.areas = append(s.areas, area)\n      s.areaOrders[area] = new(order.AreaOrder)\n    }\n    return nil\n  }\n  \n  // HasArea ...\n  func (s *BookingService) HasArea(area string) bool {\n    for _, has := range s.areas {\n      if area == has {\n        return true\n      }\n    }\n    return false\n  }\n  ```\n\n#### 6.6 【推荐】变量声明\n\n- 变量声明尽量放在变量第一次使用前面，就近原则\n\n#### 6.7 【必须】魔法数字\n\n- 如果魔法数字出现超过 2 次，则禁止使用\n  ```go\n  func getArea(r float64) float64 {\n    return 3.14 * r * r\n  }\n  \n  func getLength(r float64) float64 {\n    return 3.14 * 2 * r\n  }\n  \n  // PI ...\n  const PI = 3.14\n  func getArea(r float64) float64 {\n    return PI * r * r\n  }\n  \n  func getLength(r float64) float64 {\n    return PI * 2 * r\n  }\n  ```\n\n### 依赖管理\n\n#### 7.1 【必须】go modules\n\n- **[火箭]** go1.11 以上必须使用 go modules 模式：\n  ```bash\n  go mod init github.com/group/myrepo\n  ```\n\n#### 7.2 【推荐】代码提交\n\n- **[火箭]** 建议所有不对外开源的工程的 module name 使用 `github.com/group/repo`，方便他人直接引用\n- **[火]** 建议使用 go modules 作为依赖管理的项目不提交 vendor 目录\n- **[灯泡]** 建议使用 go modules 管理依赖的项目将 go.sum 文件不添加到忽略提交规则中\n\n### 应用服务\n\n#### 8.1 【推荐】应用服务接口建议有 readme.md\n\n- 其中建议包括服务基本描述、使用方法、部署时的限制与要求、基础环境依赖（例如最低 go 版本、最低外部通用包版本）等\n\n#### 8.2 【必须】应用服务必须要有接口测试\n\n### 常用工具\n\ngo 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范。\n\n- **[火箭]** `gofmt`，大部分的格式问题可以通过 `gofmt` 解决，`gofmt` 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 `gofmt` 的结果为准\n- **[火]** `goimports`，此工具在 `gofmt` 的基础上增加了自动删除和引入包\n- **[灯泡]** `go vet`，vet 工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前 return 的逻辑，struct 的 tag 是否符合标准等。编译前先执行代码静态分析\n- **[旗子]** `golint`，类似 javascript 中的 `jslint` 的工具，主要功能就是检测代码中不规范的地方\n\n#### 前端\n- **Static Analysis**: `eslint` + `typescript-eslint`\n- **Formatting**: `prettier`\n- **Testing Framework**:\n  - `vitest` / `jest` - 单元测试\n  - `@testing-library/react` - React 组件测试\n  - `playwright` / `cypress` - E2E 测试\n- **Type Checking**: TypeScript compiler\n\n### Version Control & Collaboration\n\n- **VCS**: Git\n- **Branching Strategy**: Git Flow\n  - `main`: 生产环境\n  - `develop`: 开发分支\n  - `feature/*`: 功能分支\n  - `fix/*`: 修复分支\n- **Code Review Process**: \n  - 所有代码必须经过 Code Review\n  - 至少一人 Approve 才能合并\n  - CI/CD 检查通过后才能合并\n\n## Deployment & Distribution\n\n### Target Platform(s)\n- **后端**: Linux (Docker 容器)\n- **前端**: 静态文件托管 (Nginx / CDN)\n- **数据库**: PostgreSQL (云服务或自托管)\n- **缓存**: Redis (云服务或自托管)\n\n### Distribution Method\n- **容器化**: Docker + Docker Compose (开发环境)\n- **Kubernetes**: 生产环境 (可选)\n- **CI/CD**: GitHub Actions / GitLab CI\n\n### Installation Requirements\n- **开发环境**:\n  - Go 1.21+\n  - Node.js 18+\n  - PostgreSQL 14+\n  - Redis 7.0+\n  - Docker & Docker Compose (推荐)\n\n### Update Mechanism\n- **数据库迁移**: 通过 migration 工具自动执行\n- **服务更新**: 滚动更新 (零停机)\n\n## Technical Requirements & Constraints\n\n### Performance Requirements\n\n- **API 响应时间**: \n  - 列表查询: < 200ms (有缓存)\n  - 详情查询: < 100ms (有缓存)\n  - 发布操作: < 500ms\n- **并发支持**: 支持 1000+ 并发请求\n- **数据库连接池**: 最大 100 连接\n- **Redis 连接池**: 最大 50 连接\n\n### Compatibility Requirements\n\n- **Go 版本**: >= 1.21\n- **PostgreSQL 版本**: >= 14.0\n- **Redis 版本**: >= 7.0\n- **Node.js 版本**: >= 18.0\n- **浏览器支持**: Chrome, Firefox, Safari, Edge (最新 2 个版本)\n\n### Security & Compliance\n\n#### Security Requirements\n- **数据加密**: \n  - 传输层: TLS 1.3\n  - 存储层: 敏感数据加密存储\n- **SQL 注入防护**: 使用参数化查询，禁止拼接 SQL\n- **XSS 防护**: 前端输入输出转义\n- **CSRF 防护**: Token 验证 (未来版本)\n- **限流**: Redis 实现接口限流，防止恶意刷接口\n- **匿名保护**: \n  - 不记录用户 IP (或加密存储)\n  - 不存储任何可追踪信息\n\n#### Compliance Standards\n- **数据隐私**: 遵循 GDPR 原则（最小化数据收集）\n- **内容合规**: 建立内容审核机制，防止违法内容\n\n#### Threat Model\n- **主要威胁**:\n  - 恶意刷接口\n  - 虚假/恶意内容发布\n  - 数据泄露\n  - DDoS 攻击\n- **防护措施**:\n  - 接口限流\n  - 内容审核（人工+自动）\n  - 数据加密\n  - CDN + WAF\n\n### Scalability & Reliability\n\n#### Expected Load\n- **初期**: 1000 DAU, 10000 条内容\n- **中期**: 10000 DAU, 100000 条内容\n- **长期**: 100000+ DAU, 1000000+ 条内容\n\n#### Availability Requirements\n- **目标可用性**: 99.9% (月度)\n- **故障恢复时间**: < 30 分钟\n- **数据备份**: 每日自动备份，保留 30 天\n\n#### Growth Projections\n- **水平扩展**: \n  - 无状态服务，支持多实例部署\n  - 数据库读写分离（未来）\n  - Redis 集群（未来）\n- **垂直扩展**: \n  - 数据库索引优化\n  - 缓存策略优化\n\n## Technical Decisions & Rationale\n\n### Decision Log\n\n1. **选择 gRPC 而非 REST API**\n   - **原因**: \n     - 类型安全（protobuf）\n     - 性能更好（二进制协议）\n     - 支持流式传输（未来实时功能）\n     - 代码生成，减少手写代码\n   - **权衡**: 需要前端使用 gRPC-Web，增加复杂度\n\n2. **采用 DDD 架构**\n   - **原因**:\n     - 业务逻辑清晰，易于维护\n     - 领域模型与基础设施解耦\n     - 便于测试（依赖注入）\n     - 支持未来功能扩展\n   - **权衡**: 初期开发复杂度较高，但长期收益大\n\n3. **PostgreSQL + Redis 组合**\n   - **原因**:\n     - PostgreSQL: 关系型数据，支持复杂查询和全文搜索\n     - Redis: 高性能缓存，支持复杂数据结构\n     - 两者互补，满足不同场景需求\n   - **权衡**: 需要维护两套存储系统\n\n4. **使用 TypeScript 而非 JavaScript**\n   - **原因**:\n     - 类型安全，减少运行时错误\n     - 更好的 IDE 支持\n     - 代码可读性更好\n   - **权衡**: 需要编译步骤，但收益远大于成本\n\n5. **前端使用 React + 现代构建工具**\n   - **原因**:\n     - React 生态成熟，组件库丰富\n     - Vite 构建速度快，开发体验好\n     - 支持 SSR（未来版本）\n   - **权衡**: 学习曲线，但团队熟悉度高\n\n## Testing & Verification Strategy\n\n### 测试金字塔\n\n```\n        /\\\n       /E2E\\         少量端到端测试\n      /────\\\n     /Integration\\  集成测试（数据库、Redis）\n    /────────────\\\n   /   Unit Test   \\ 大量单元测试\n  /────────────────\\\n```\n\n### 测试要求\n\n#### 1. 单元测试\n- **覆盖率要求**: >= 70% (核心业务逻辑 >= 90%)\n- **测试范围**:\n  - Domain Layer: 所有实体、值对象、领域服务\n  - Application Layer: 所有 Use Cases\n  - Infrastructure Layer: Repository 实现\n- **Mock 策略**: \n  - 使用 `gomock` 生成接口 mock\n  - 测试时隔离外部依赖（数据库、Redis）\n\n#### 2. 集成测试\n- **测试范围**:\n  - Repository 与数据库集成\n  - Redis 缓存集成\n  - gRPC 服务端集成\n- **测试环境**: \n  - 使用 Docker Compose 启动测试数据库和 Redis\n  - 每个测试用例使用独立的事务，测试后回滚\n\n#### 3. 端到端测试\n- **测试范围**:\n  - 完整的用户流程（发布、查看、搜索）\n  - API 端到端测试\n- **工具**: \n  - 后端: `httptest` + gRPC 测试客户端\n  - 前端: Playwright / Cypress\n\n### 三方组件验证流程\n\n**重要原则**: 设计三方组件时，必须保证调通后再进入下一步。\n\n#### 验证步骤\n\n1. **组件设计阶段**\n   - 定义接口和依赖\n   - 编写接口测试用例\n\n2. **实现阶段**\n   - 实现组件功能\n   - 编写单元测试\n\n3. **集成验证阶段** ⚠️ **必须完成此步骤**\n   - 启动真实依赖（PostgreSQL、Redis）\n   - 编写集成测试，验证组件与依赖的交互\n   - **确保所有测试通过**\n   - 验证错误处理和边界情况\n\n4. **文档更新**\n   - 更新组件使用文档\n   - 记录已知问题和限制\n\n5. **进入下一步**\n   - 只有集成验证通过后，才能继续开发依赖该组件的功能\n\n#### 示例：Redis 缓存组件验证\n\n```go\n// 1. 定义接口\ntype CacheRepository interface {\n    Get(ctx context.Context, key string) (string, error)\n    Set(ctx context.Context, key string, value string, ttl time.Duration) error\n}\n\n// 2. 实现\ntype RedisCache struct {\n    client *redis.Client\n}\n\n// 3. 集成测试（必须通过）\nfunc TestRedisCache_Integration(t *testing.T) {\n    // 启动真实 Redis（Docker）\n    client := setupRedis(t)\n    cache := NewRedisCache(client)\n    \n    // 测试 Get/Set\n    err := cache.Set(ctx, \"test\", \"value\", time.Minute)\n    require.NoError(t, err)\n    \n    val, err := cache.Get(ctx, \"test\")\n    require.NoError(t, err)\n    require.Equal(t, \"value\", val)\n    \n    // 测试 TTL\n    // 测试错误处理\n    // ...\n}\n\n// 4. 只有测试通过后，才能在其他地方使用\n```\n\n### 持续集成\n\n- **CI Pipeline**:\n  1. 代码检查 (lint)\n  2. 单元测试\n  3. 集成测试（需要 Docker）\n  4. 构建\n  5. 部署到测试环境\n\n- **测试环境**: \n  - 使用 Docker Compose 提供 PostgreSQL 和 Redis\n  - 每次 CI 运行都使用干净的环境\n\n## Known Limitations\n\n1. **第一版本不支持用户认证**\n   - **影响**: 无法追踪发布者，无法实现个人中心\n   - **解决方案**: 未来版本引入匿名用户系统\n\n2. **内容审核依赖人工**\n   - **影响**: 审核效率低，可能存在延迟\n   - **解决方案**: 未来引入自动审核 + 人工复核\n\n3. **搜索功能基于 PostgreSQL 全文搜索**\n   - **影响**: 性能和功能有限\n   - **解决方案**: 未来引入 Elasticsearch 或 Meilisearch\n\n4. **单数据库架构**\n   - **影响**: 高并发时可能成为瓶颈\n   - **解决方案**: 未来实现读写分离、分库分表\n\n",
  "fileStats": {
    "size": 33758,
    "lines": 1097,
    "lastModified": "2026-01-06T03:51:12.209Z"
  },
  "comments": []
}