
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>content: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">fuck_boss/backend/internal/application/content/create_post.go (97.7%)</option>
				
				<option value="file1">fuck_boss/backend/internal/application/content/list_posts.go (91.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package content provides use cases for content management.
package content

import (
        "context"
        "fmt"
        "time"

        "fuck_boss/backend/internal/application/cache"
        "fuck_boss/backend/internal/application/dto"
        "fuck_boss/backend/internal/application/ratelimit"
        "fuck_boss/backend/internal/domain/content"
        "fuck_boss/backend/internal/domain/shared"
        apperrors "fuck_boss/backend/pkg/errors"
)

// CreatePostCommand represents the command to create a new post.
type CreatePostCommand struct {
        // Company is the company name (required, 1-100 characters).
        Company string

        // CityCode is the city code (required, e.g., "beijing").
        CityCode string

        // CityName is the city name (required, e.g., "北京").
        // This is needed to create the City value object.
        CityName string

        // Content is the post content (required, 10-5000 characters).
        Content string

        // OccurredAt is when the incident occurred (optional).
        OccurredAt *time.Time

        // ClientIP is the client IP address for rate limiting (required).
        ClientIP string
}

// CreatePostUseCase handles the creation of posts.
// It coordinates domain entities, repositories, caching, and rate limiting.
type CreatePostUseCase struct {
        // repo is the Post repository.
        repo content.PostRepository

        // cacheRepo is the cache repository for cache invalidation.
        cacheRepo cache.CacheRepository

        // rateLimiter is the rate limiter for preventing abuse.
        rateLimiter ratelimit.RateLimiter
}

// NewCreatePostUseCase creates a new CreatePostUseCase instance.
func NewCreatePostUseCase(
        repo content.PostRepository,
        cacheRepo cache.CacheRepository,
        rateLimiter ratelimit.RateLimiter,
) *CreatePostUseCase <span class="cov8" title="1">{
        return &amp;CreatePostUseCase{
                repo:        repo,
                cacheRepo:   cacheRepo,
                rateLimiter: rateLimiter,
        }
}</span>

// Execute executes the create post command.
// It performs validation, rate limiting, creates the post, saves it, and clears cache.
func (uc *CreatePostUseCase) Execute(ctx context.Context, cmd CreatePostCommand) (*dto.PostDTO, error) <span class="cov8" title="1">{
        // 1. Validate input
        if err := uc.validateCommand(cmd); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 2. Check rate limit (3 requests per hour per IP)
        <span class="cov8" title="1">rateLimitKey := uc.buildRateLimitKey(cmd.ClientIP)
        allowed, err := uc.rateLimiter.Allow(ctx, rateLimitKey, 3, time.Hour)
        if err != nil </span><span class="cov8" title="1">{
                // If rate limiter fails, log but continue (graceful degradation)
                // In production, you might want to fail or use a different strategy
                return nil, apperrors.NewDatabaseErrorWithCause("rate limit check failed", err)
        }</span>
        <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                return nil, apperrors.NewRateLimitError("rate limit exceeded: maximum 3 posts per hour")
        }</span>

        // 3. Create domain value objects
        <span class="cov8" title="1">company, err := content.NewCompanyName(cmd.Company)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.NewValidationErrorWithDetails("invalid company name", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov8" title="1">city, err := shared.NewCity(cmd.CityCode, cmd.CityName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.NewValidationErrorWithDetails("invalid city", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        <span class="cov8" title="1">postContent, err := content.NewContent(cmd.Content)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.NewValidationErrorWithDetails("invalid content", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        // 4. Create Post entity
        <span class="cov8" title="1">post, err := content.NewPost(company, city, postContent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.NewInternalErrorWithCause("failed to create post", err)
        }</span>

        // 5. Save to repository
        <span class="cov8" title="1">err = uc.repo.Save(ctx, post)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 6. Clear related cache
        // Clear city list cache for the city
        <span class="cov8" title="1">cachePattern := fmt.Sprintf("posts:city:%s:*", city.Code())
        err = uc.cacheRepo.DeleteByPattern(ctx, cachePattern)
        if err != nil </span>{<span class="cov8" title="1">
                // Log error but don't fail the operation
                // Cache invalidation failure should not prevent post creation
                // In production, you might want to log this error
        }</span>

        // 7. Convert to DTO and return
        <span class="cov8" title="1">return uc.toDTO(post, cmd.OccurredAt), nil</span>
}

// validateCommand validates the create post command.
func (uc *CreatePostUseCase) validateCommand(cmd CreatePostCommand) error <span class="cov8" title="1">{
        if cmd.Company == "" </span><span class="cov8" title="1">{
                return apperrors.NewValidationError("company name is required")
        }</span>

        <span class="cov8" title="1">if cmd.CityCode == "" </span><span class="cov8" title="1">{
                return apperrors.NewValidationError("city code is required")
        }</span>

        <span class="cov8" title="1">if cmd.CityName == "" </span><span class="cov8" title="1">{
                return apperrors.NewValidationError("city name is required")
        }</span>

        <span class="cov8" title="1">if cmd.Content == "" </span><span class="cov8" title="1">{
                return apperrors.NewValidationError("content is required")
        }</span>

        <span class="cov8" title="1">if cmd.ClientIP == "" </span><span class="cov8" title="1">{
                return apperrors.NewValidationError("client IP is required for rate limiting")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// buildRateLimitKey builds the rate limit key for the given IP.
// Format: "rate_limit:post:{ip}:{hour}"
func (uc *CreatePostUseCase) buildRateLimitKey(ip string) string <span class="cov8" title="1">{
        now := time.Now()
        hour := now.Format("2006-01-02-15") // Format: YYYY-MM-DD-HH
        return fmt.Sprintf("rate_limit:post:%s:%s", ip, hour)
}</span>

// toDTO converts a Post entity to PostDTO.
func (uc *CreatePostUseCase) toDTO(post *content.Post, occurredAt *time.Time) *dto.PostDTO <span class="cov8" title="1">{
        return &amp;dto.PostDTO{
                ID:         post.ID().String(),
                Company:    post.Company().String(),
                CityCode:   post.City().Code(),
                CityName:   post.City().Name(),
                Content:    post.Content().String(),
                OccurredAt: occurredAt,
                CreatedAt:  post.CreatedAt(),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package content provides use cases for content management.
package content

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "fuck_boss/backend/internal/application/cache"
        "fuck_boss/backend/internal/application/dto"
        "fuck_boss/backend/internal/domain/content"
        "fuck_boss/backend/internal/domain/shared"
        apperrors "fuck_boss/backend/pkg/errors"
)

// ListPostsQuery represents the query parameters for listing posts.
type ListPostsQuery struct {
        // CityCode is the city code to filter by (required).
        CityCode string

        // Page is the page number (1-based, default: 1).
        Page int

        // PageSize is the number of items per page (default: 20).
        PageSize int
}

// ListPostsUseCase handles listing posts by city with caching.
// It coordinates domain repository and cache repository.
type ListPostsUseCase struct {
        // repo is the Post repository.
        repo content.PostRepository

        // cacheRepo is the cache repository for caching query results.
        cacheRepo cache.CacheRepository
}

// NewListPostsUseCase creates a new ListPostsUseCase instance.
func NewListPostsUseCase(
        repo content.PostRepository,
        cacheRepo cache.CacheRepository,
) *ListPostsUseCase <span class="cov8" title="1">{
        return &amp;ListPostsUseCase{
                repo:      repo,
                cacheRepo: cacheRepo,
        }
}</span>

// Execute executes the list posts query.
// It checks cache first, then queries the repository if cache misses.
func (uc *ListPostsUseCase) Execute(ctx context.Context, query ListPostsQuery) (*dto.PostsListDTO, error) <span class="cov8" title="1">{
        // Validate and set defaults
        if err := uc.validateQuery(query); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">page := query.Page
        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>

        <span class="cov8" title="1">pageSize := query.PageSize
        if pageSize &lt; 1 </span><span class="cov8" title="1">{
                pageSize = 20
        }</span>

        // Create city value object
        <span class="cov8" title="1">city, err := shared.NewCity(query.CityCode, uc.getCityName(query.CityCode))
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperrors.NewValidationErrorWithDetails("invalid city code", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        // Build cache key
        <span class="cov8" title="1">cacheKey := uc.buildCacheKey(city.Code(), page)

        // Try to get from cache
        cachedData, err := uc.cacheRepo.Get(ctx, cacheKey)
        if err == nil &amp;&amp; cachedData != "" </span><span class="cov8" title="1">{
                // Cache hit: deserialize and return
                var result dto.PostsListDTO
                if err := json.Unmarshal([]byte(cachedData), &amp;result); err == nil </span><span class="cov8" title="1">{
                        return &amp;result, nil
                }</span>
                // If deserialization fails, continue to query database
        }

        // Cache miss or error: query repository
        <span class="cov8" title="1">posts, total, err := uc.repo.FindByCity(ctx, city, page, pageSize)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperrors.NewDatabaseErrorWithCause("failed to query posts", err)
        }</span>

        // Convert to DTO
        <span class="cov8" title="1">result := &amp;dto.PostsListDTO{
                Posts:    uc.toDTOs(posts),
                Total:    total,
                Page:     page,
                PageSize: pageSize,
        }

        // Update cache (non-blocking, errors are ignored)
        uc.updateCache(ctx, cacheKey, result, city.Code())

        return result, nil</span>
}

// validateQuery validates the list posts query.
func (uc *ListPostsUseCase) validateQuery(query ListPostsQuery) error <span class="cov8" title="1">{
        if query.CityCode == "" </span><span class="cov8" title="1">{
                return apperrors.NewValidationError("city code is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// buildCacheKey builds the cache key for the given city and page.
// Format: "posts:city:{cityCode}:page:{page}"
func (uc *ListPostsUseCase) buildCacheKey(cityCode string, page int) string <span class="cov8" title="1">{
        return fmt.Sprintf("posts:city:%s:page:%d", cityCode, page)
}</span>

// getCityName returns the city name for the given city code.
// This is a temporary implementation. In production, you should use a city repository or configuration.
func (uc *ListPostsUseCase) getCityName(cityCode string) string <span class="cov8" title="1">{
        // Simple mapping for common cities
        cityMap := map[string]string{
                "beijing":   "北京",
                "shanghai":  "上海",
                "guangzhou": "广州",
                "shenzhen":  "深圳",
                "hangzhou":  "杭州",
                "nanjing":   "南京",
                "chengdu":   "成都",
                "wuhan":     "武汉",
                "xian":      "西安",
                "tianjin":   "天津",
        }

        if name, ok := cityMap[cityCode]; ok </span><span class="cov8" title="1">{
                return name
        }</span>

        // If not found, return the code as fallback
        // In production, you should query from a city repository or configuration
        <span class="cov0" title="0">return cityCode</span>
}

// getCacheTTL returns the cache TTL based on city popularity.
// Popular cities (beijing, shanghai) get shorter TTL (5 minutes).
// Other cities get longer TTL (10 minutes).
func (uc *ListPostsUseCase) getCacheTTL(cityCode string) time.Duration <span class="cov8" title="1">{
        popularCities := map[string]bool{
                "beijing":  true,
                "shanghai": true,
                "guangzhou": true,
                "shenzhen": true,
        }

        if popularCities[cityCode] </span><span class="cov8" title="1">{
                return 5 * time.Minute
        }</span>
        <span class="cov0" title="0">return 10 * time.Minute</span>
}

// updateCache updates the cache with the query result.
// Errors are ignored to ensure cache failures don't affect the main flow.
func (uc *ListPostsUseCase) updateCache(ctx context.Context, key string, result *dto.PostsListDTO, cityCode string) <span class="cov8" title="1">{
        // Serialize to JSON
        data, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail
                return
        }</span>

        // Get TTL based on city popularity
        <span class="cov8" title="1">ttl := uc.getCacheTTL(cityCode)

        // Set cache (non-blocking)
        _ = uc.cacheRepo.Set(ctx, key, string(data), ttl)</span>
}

// toDTOs converts a slice of Post entities to PostDTOs.
func (uc *ListPostsUseCase) toDTOs(posts []*content.Post) []*dto.PostDTO <span class="cov8" title="1">{
        dtos := make([]*dto.PostDTO, 0, len(posts))
        for _, post := range posts </span><span class="cov8" title="1">{
                dtos = append(dtos, uc.toDTO(post))
        }</span>
        <span class="cov8" title="1">return dtos</span>
}

// toDTO converts a Post entity to PostDTO.
func (uc *ListPostsUseCase) toDTO(post *content.Post) *dto.PostDTO <span class="cov8" title="1">{
        return &amp;dto.PostDTO{
                ID:        post.ID().String(),
                Company:   post.Company().String(),
                CityCode:  post.City().Code(),
                CityName:  post.City().Name(),
                Content:   post.Content().String(),
                OccurredAt: nil, // Not stored in Post entity
                CreatedAt: post.CreatedAt(),
        }
}</span>

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
